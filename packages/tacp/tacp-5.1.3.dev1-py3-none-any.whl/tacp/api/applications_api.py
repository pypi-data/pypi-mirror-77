#   Copyright (c) 2020 Lenovo.  All rights reserved.

#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at

#       http://www.apache.org/licenses/LICENSE-2.0

#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.


"""
    CP Web Services (CPWS)

    CP web services provides API access to the ThinkAgile CP on-premises cloud platform. It provides access to virtual datacenter and infrastructure resources and is used to create resizable resources, manage workloads and retrieve information about the underlying infrastructure. CPWS will continue to grow as new capabilities are added to the platform.  # noqa: E501

    OpenAPI spec version: Beta
    Contact: lenovo-email
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tacp.api_client import ApiClient


class ApplicationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def clone_and_attach_disk_to_application_using_put(self, body, uuid, **kwargs):  # noqa: E501
        """Clone and attach a disk to an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_and_attach_disk_to_application_using_put(body, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiUuidPayload body: payload (required)
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.clone_and_attach_disk_to_application_using_put_with_http_info(body, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.clone_and_attach_disk_to_application_using_put_with_http_info(body, uuid, **kwargs)  # noqa: E501
            return data

    def clone_and_attach_disk_to_application_using_put_with_http_info(self, body, uuid, **kwargs):  # noqa: E501
        """Clone and attach a disk to an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_and_attach_disk_to_application_using_put_with_http_info(body, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiUuidPayload body: payload (required)
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clone_and_attach_disk_to_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `clone_and_attach_disk_to_application_using_put`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `clone_and_attach_disk_to_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/clone-and-attach-disk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_application_from_snapshot_using_post(self, body, **kwargs):  # noqa: E501
        """Create an application from a snapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_from_snapshot_using_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiCreateApplicationPayload body: payload (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_application_from_snapshot_using_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_application_from_snapshot_using_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_application_from_snapshot_using_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create an application from a snapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_from_snapshot_using_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiCreateApplicationPayload body: payload (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_application_from_snapshot_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_application_from_snapshot_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/create-from-snapshot', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_application_from_template_using_post(self, body, **kwargs):  # noqa: E501
        """Create an application from a template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_from_template_using_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiCreateApplicationPayload body: payload (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_application_from_template_using_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_application_from_template_using_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_application_from_template_using_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create an application from a template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_from_template_using_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiCreateApplicationPayload body: payload (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_application_from_template_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_application_from_template_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_snapshot_for_application_using_post(self, body, uuid, **kwargs):  # noqa: E501
        """Create a snapshot for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_snapshot_for_application_using_post(body, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiCreateSnapshotPayload body: payload (required)
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_snapshot_for_application_using_post_with_http_info(body, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_snapshot_for_application_using_post_with_http_info(body, uuid, **kwargs)  # noqa: E501
            return data

    def create_snapshot_for_application_using_post_with_http_info(self, body, uuid, **kwargs):  # noqa: E501
        """Create a snapshot for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_snapshot_for_application_using_post_with_http_info(body, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiCreateSnapshotPayload body: payload (required)
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_snapshot_for_application_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_snapshot_for_application_using_post`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `create_snapshot_for_application_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/snapshots', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_application_using_delete(self, uuid, **kwargs):  # noqa: E501
        """Delete an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_using_delete(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_application_using_delete_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_application_using_delete_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def delete_application_using_delete_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Delete an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_using_delete_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_application_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `delete_application_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_snapshot_for_application_using_delete(self, snapshot_uuid, uuid, **kwargs):  # noqa: E501
        """Deleting snapshot for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_snapshot_for_application_using_delete(snapshot_uuid, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str snapshot_uuid: snapshot_uuid (required)
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_snapshot_for_application_using_delete_with_http_info(snapshot_uuid, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_snapshot_for_application_using_delete_with_http_info(snapshot_uuid, uuid, **kwargs)  # noqa: E501
            return data

    def delete_snapshot_for_application_using_delete_with_http_info(self, snapshot_uuid, uuid, **kwargs):  # noqa: E501
        """Deleting snapshot for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_snapshot_for_application_using_delete_with_http_info(snapshot_uuid, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str snapshot_uuid: snapshot_uuid (required)
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['snapshot_uuid', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_snapshot_for_application_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'snapshot_uuid' is set
        if ('snapshot_uuid' not in params or
                params['snapshot_uuid'] is None):
            raise ValueError("Missing the required parameter `snapshot_uuid` when calling `delete_snapshot_for_application_using_delete`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `delete_snapshot_for_application_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'snapshot_uuid' in params:
            path_params['snapshot_uuid'] = params['snapshot_uuid']  # noqa: E501
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/snapshots/{snapshot_uuid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_application_using_put(self, uuid, **kwargs):  # noqa: E501
        """Edit an application (deprecated)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_application_using_put(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def edit_application_using_put_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Edit an application (deprecated)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_application_using_put_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `edit_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def force_restart_application_using_put(self, uuid, **kwargs):  # noqa: E501
        """Force restart an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.force_restart_application_using_put(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.force_restart_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.force_restart_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def force_restart_application_using_put_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Force restart an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.force_restart_application_using_put_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method force_restart_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `force_restart_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/force-restart', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_disk_stats_using_get(self, disk_uuid, uuid, **kwargs):  # noqa: E501
        """View disk statistics for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_disk_stats_using_get(disk_uuid, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str disk_uuid: disk_uuid (required)
        :param str uuid: uuid (required)
        :param datetime end_timestamp: return disk statistics for an application finishing at the specified timestamp. Timestamp should be in the user's timezone.
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of disk statistics for an application returned
        :param int offset: returns disk statistics for an application starting at the specified index in the list
        :param datetime start_timestamp: return disk statistics for an application starting at the specified timestamp. Timestamp should be in the user's timezone.
        :return: list[ApiDiskStatsPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_disk_stats_using_get_with_http_info(disk_uuid, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_disk_stats_using_get_with_http_info(disk_uuid, uuid, **kwargs)  # noqa: E501
            return data

    def get_application_disk_stats_using_get_with_http_info(self, disk_uuid, uuid, **kwargs):  # noqa: E501
        """View disk statistics for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_disk_stats_using_get_with_http_info(disk_uuid, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str disk_uuid: disk_uuid (required)
        :param str uuid: uuid (required)
        :param datetime end_timestamp: return disk statistics for an application finishing at the specified timestamp. Timestamp should be in the user's timezone.
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of disk statistics for an application returned
        :param int offset: returns disk statistics for an application starting at the specified index in the list
        :param datetime start_timestamp: return disk statistics for an application starting at the specified timestamp. Timestamp should be in the user's timezone.
        :return: list[ApiDiskStatsPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['disk_uuid', 'uuid', 'end_timestamp', 'fields', 'filters', 'limit', 'offset', 'start_timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_disk_stats_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'disk_uuid' is set
        if ('disk_uuid' not in params or
                params['disk_uuid'] is None):
            raise ValueError("Missing the required parameter `disk_uuid` when calling `get_application_disk_stats_using_get`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_application_disk_stats_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'disk_uuid' in params:
            path_params['disk_uuid'] = params['disk_uuid']  # noqa: E501
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []
        if 'end_timestamp' in params:
            query_params.append(('end-timestamp', params['end_timestamp']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501
        if 'filters' in params:
            query_params.append(('filters', params['filters']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'start_timestamp' in params:
            query_params.append(('start-timestamp', params['start_timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/disks/{disk_uuid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ApiDiskStatsPayload]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_stats_using_get(self, uuid, **kwargs):  # noqa: E501
        """View statistics for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_stats_using_get(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :param datetime end_timestamp: return statistics for an application finishing at the specified timestamp. Timestamp should be in the user's timezone.
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of statistics for an application returned
        :param int offset: returns statistics for an application starting at the specified index in the list
        :param datetime start_timestamp: return statistics for an application starting at the specified timestamp. Timestamp should be in the user's timezone.
        :return: list[ApiApplicationInstanceStatsPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_stats_using_get_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_stats_using_get_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def get_application_stats_using_get_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """View statistics for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_stats_using_get_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :param datetime end_timestamp: return statistics for an application finishing at the specified timestamp. Timestamp should be in the user's timezone.
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of statistics for an application returned
        :param int offset: returns statistics for an application starting at the specified index in the list
        :param datetime start_timestamp: return statistics for an application starting at the specified timestamp. Timestamp should be in the user's timezone.
        :return: list[ApiApplicationInstanceStatsPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid', 'end_timestamp', 'fields', 'filters', 'limit', 'offset', 'start_timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_stats_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_application_stats_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []
        if 'end_timestamp' in params:
            query_params.append(('end-timestamp', params['end_timestamp']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501
        if 'filters' in params:
            query_params.append(('filters', params['filters']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'start_timestamp' in params:
            query_params.append(('start-timestamp', params['start_timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ApiApplicationInstanceStatsPayload]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_using_get(self, uuid, **kwargs):  # noqa: E501
        """View an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_using_get(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :return: ApiApplicationInstancePropertiesPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_using_get_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_using_get_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def get_application_using_get_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """View an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_using_get_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :return: ApiApplicationInstancePropertiesPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_application_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiApplicationInstancePropertiesPayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applications_using_get(self, **kwargs):  # noqa: E501
        """View applications for an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of applications returned
        :param int offset: returns applications starting at the specified index in the list
        :return: list[ApiApplicationInstancePropertiesPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_applications_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_applications_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_applications_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """View applications for an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of applications returned
        :param int offset: returns applications starting at the specified index in the list
        :return: list[ApiApplicationInstancePropertiesPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'filters', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applications_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501
        if 'filters' in params:
            query_params.append(('filters', params['filters']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ApiApplicationInstancePropertiesPayload]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_overrides_for_application_using_get(self, uuid, **kwargs):  # noqa: E501
        """View a list of firewall overrides for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_overrides_for_application_using_get(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of firewall overrides for an application returned
        :param int offset: returns firewall overrides for an application starting at the specified index in the list
        :return: list[ApiFirewallProfilePropertiesPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_firewall_overrides_for_application_using_get_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_overrides_for_application_using_get_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def get_firewall_overrides_for_application_using_get_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """View a list of firewall overrides for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_overrides_for_application_using_get_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of firewall overrides for an application returned
        :param int offset: returns firewall overrides for an application starting at the specified index in the list
        :return: list[ApiFirewallProfilePropertiesPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid', 'fields', 'filters', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_overrides_for_application_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_firewall_overrides_for_application_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501
        if 'filters' in params:
            query_params.append(('filters', params['filters']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/firewall-overrides', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ApiFirewallProfilePropertiesPayload]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_snapshot_using_get(self, snapshot_uuid, uuid, **kwargs):  # noqa: E501
        """View a snapshot for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_snapshot_using_get(snapshot_uuid, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str snapshot_uuid: snapshot_uuid (required)
        :param str uuid: uuid (required)
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :return: ApiSnapshotBootOrderPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_snapshot_using_get_with_http_info(snapshot_uuid, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_snapshot_using_get_with_http_info(snapshot_uuid, uuid, **kwargs)  # noqa: E501
            return data

    def get_snapshot_using_get_with_http_info(self, snapshot_uuid, uuid, **kwargs):  # noqa: E501
        """View a snapshot for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_snapshot_using_get_with_http_info(snapshot_uuid, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str snapshot_uuid: snapshot_uuid (required)
        :param str uuid: uuid (required)
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :return: ApiSnapshotBootOrderPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['snapshot_uuid', 'uuid', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_snapshot_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'snapshot_uuid' is set
        if ('snapshot_uuid' not in params or
                params['snapshot_uuid'] is None):
            raise ValueError("Missing the required parameter `snapshot_uuid` when calling `get_snapshot_using_get`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_snapshot_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'snapshot_uuid' in params:
            path_params['snapshot_uuid'] = params['snapshot_uuid']  # noqa: E501
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/snapshots/{snapshot_uuid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSnapshotBootOrderPayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_snapshots_for_application_using_get(self, uuid, **kwargs):  # noqa: E501
        """View snapshots for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_snapshots_for_application_using_get(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of statistics for an application returned
        :param int offset: returns snapshots for an application starting at the specified index in the list
        :return: list[ApiSnapshotBootOrderPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_snapshots_for_application_using_get_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_snapshots_for_application_using_get_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def get_snapshots_for_application_using_get_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """View snapshots for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_snapshots_for_application_using_get_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :param list[str] fields: Selector specifying a subset of fields to include in the response. Supports dotted notation to traverse into child objects. (Example: ?fields=foo.bar.uuid,foo.name)
        :param str filters: Selector specifying filters in FIQL notation to apply to the response items. Supports dotted notation to traverse into child objects. (Example: ?filters=foo.bar.id=in=(1,2,3) or foo.bar.name==\"name\") Supported comparison operators: Equal to: == Not equal to: != Less than: =lt= or < Less than or equal to: =le= or <= Greater than operator: =gt= or > Greater than or equal to: =ge= or >= In: =in= Not in: =out=
        :param int limit: limit the number of statistics for an application returned
        :param int offset: returns snapshots for an application starting at the specified index in the list
        :return: list[ApiSnapshotBootOrderPayload]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid', 'fields', 'filters', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_snapshots_for_application_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_snapshots_for_application_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501
        if 'filters' in params:
            query_params.append(('filters', params['filters']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/snapshots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ApiSnapshotBootOrderPayload]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pause_application_using_put(self, uuid, **kwargs):  # noqa: E501
        """Pause an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_application_using_put(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pause_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.pause_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def pause_application_using_put_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Pause an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_application_using_put_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pause_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `pause_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/suspend', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rename_snapshot_using_put(self, body, snapshot_uuid, uuid, **kwargs):  # noqa: E501
        """Rename a snapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_snapshot_using_put(body, snapshot_uuid, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiSnapshotPayload body: payload (required)
        :param str snapshot_uuid: snapshot_uuid (required)
        :param str uuid: uuid (required)
        :return: ApiMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.rename_snapshot_using_put_with_http_info(body, snapshot_uuid, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.rename_snapshot_using_put_with_http_info(body, snapshot_uuid, uuid, **kwargs)  # noqa: E501
            return data

    def rename_snapshot_using_put_with_http_info(self, body, snapshot_uuid, uuid, **kwargs):  # noqa: E501
        """Rename a snapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_snapshot_using_put_with_http_info(body, snapshot_uuid, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiSnapshotPayload body: payload (required)
        :param str snapshot_uuid: snapshot_uuid (required)
        :param str uuid: uuid (required)
        :return: ApiMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'snapshot_uuid', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rename_snapshot_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `rename_snapshot_using_put`")  # noqa: E501
        # verify the required parameter 'snapshot_uuid' is set
        if ('snapshot_uuid' not in params or
                params['snapshot_uuid'] is None):
            raise ValueError("Missing the required parameter `snapshot_uuid` when calling `rename_snapshot_using_put`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `rename_snapshot_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'snapshot_uuid' in params:
            path_params['snapshot_uuid'] = params['snapshot_uuid']  # noqa: E501
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/snapshots/{snapshot_uuid}/name', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restart_application_using_put(self, uuid, **kwargs):  # noqa: E501
        """Restart an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_application_using_put(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restart_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.restart_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def restart_application_using_put_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Restart an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_application_using_put_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restart_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `restart_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/restart', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resume_application_using_put(self, uuid, **kwargs):  # noqa: E501
        """Resume an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_application_using_put(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resume_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.resume_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def resume_application_using_put_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Resume an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_application_using_put_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `resume_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/resume', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shutdown_application_using_put(self, uuid, **kwargs):  # noqa: E501
        """Shutdown an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown_application_using_put(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.shutdown_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.shutdown_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def shutdown_application_using_put_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Shutdown an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown_application_using_put_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shutdown_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `shutdown_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/shutdown', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_application_using_put(self, uuid, **kwargs):  # noqa: E501
        """Start an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_application_using_put(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.start_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def start_application_using_put_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Start an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_application_using_put_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `start_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/start', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_application_using_put(self, uuid, **kwargs):  # noqa: E501
        """Stop an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_application_using_put(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.stop_application_using_put_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def stop_application_using_put_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """Stop an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_application_using_put_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: uuid (required)
        :return: ApiSlamActionRequestWithMessagePayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_application_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `stop_application_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/api/latest/applications/{uuid}/stop', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSlamActionRequestWithMessagePayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
