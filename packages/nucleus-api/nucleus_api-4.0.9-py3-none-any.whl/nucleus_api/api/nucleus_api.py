# coding: utf-8

"""
    Nucleus API

    Nucleus text analytics APIs from SumUp Analytics. Example and documentation: https://www.sumup.ai/apis/#nucleus-documentation  # noqa: E501

    OpenAPI spec version: v4.0.9
    Contact: info@sumup.ai
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401
import time

# python 2 and python 3 compatibility library
import six
import numpy as np
import os
from multiprocessing import Pool
from functools import partial
import json
import sys
import nucleus_api
from nucleus_api.api_client import ApiClient
from nucleus_api.rest import ApiException
import uuid


###############################################################################
# Helpfer functions
###############################################################################
#
# Import JSON records in parallel
#
global_dataset = None
global_api_instance = None
def _upload_json(row):
    payload = nucleus_api.Appendjsonparams(dataset=global_dataset,
                                           # language='english', #optional. language can be auto detected
                                           document=row
                                           )

    try:
        api_response = global_api_instance.post_append_json_to_dataset(payload)
        return api_response.result
    except ApiException as e:
        print("Exception when calling DatasetsApi->post_append_json_to_dataset: %s\n" % e)


#
# Import JSON records into a dataset with parallel processes
# api_instance: handle to Nucleus API instance
# dataset: name of the dataset
# language: to specify the dataset language instead of detecting language based on first document inserted
# json_iters: iterable containing JSONs
# processes: number of parallel processes. Default=4
#
def upload_jsons(api_instance, dataset, json_iter, language="", processes=4, dateformat=None):
    json_iter = list(json_iter)
    # get json_iter size
    json_iter_size = 0
    for ji in json_iter:
        json_iter_size += sys.getsizeof(ji['title'])
        json_iter_size += sys.getsizeof(ji['content'])
        json_iter_size += sys.getsizeof(ji['time'])

    chunks = int(json_iter_size/(8*1024*1024) + 1)
    json_per_chunk = int(len(json_iter)/chunks)
    json_iter_chunks = []
    for i in range(chunks-1):
        json_iter_chunks.append(json_iter[(i*json_per_chunk):(i*json_per_chunk)+json_per_chunk-1])

    # get the rest of list
    json_iter_chunks.append(json_iter[((chunks-1)*json_per_chunk):])

    #print('DEBUG: size={} chunks={} json_per_chunk={} json_chunnks_len={}'.format(json_iter_size,
    #                                                                              chunks,
    #                                                                              json_per_chunk,
    #                                                                              len(json_iter_chunks)))

    result = []
    for i,json_iter_chunk in enumerate(json_iter_chunks):
        try:
            api_response = api_instance.post_bulk_insert_json(
                {"dataset": dataset, "language": language,
                 "documents": list(json_iter_chunks[i]), "dateformat": dateformat})
            result.append(api_response.result)
        except ApiException as e:
            print("Exception when calling DatasetsApi->post_bulk_insert_json: %s\n" % e)

    return result


###############################################################################
#
# Import a single file
#
def _upload_file(file):
    filename = file.get('filename')
    if filename == None:
        print('ERROR: key \'filename\' is required in the file iterable')
        return

    metadata = file.get('metadata')
    exists = os.path.isfile(filename)

    if not exists:
        print('ERROR:', filename, 'not exist')
        return

    try:
        api_response = global_api_instance.post_upload_file(
            filename,
            global_dataset,
            metadata=metadata)

        #print('INFO:', api_response.result, 'imported.')
        return api_response.result
    except ApiException as e:
        print("Exception when calling post_upload_file: %s\n" % e)


#
# Import files into a dataset with parallel processes
# Inputs:
#     api_instance: handle to Nucleus API instance
#     dataset: name of the dataset
#     file_iters: iterable containing full file paths
#     processes: number of parallel processes. Default=4
#
# Output:
#     file_props: list of file properties {filename, size)
#
def upload_files(api_instance, dataset, file_iter, processes=4):
    # partial() function not work well with pool, use global variables as a workaround
    global global_api_instance
    global global_dataset

    global_api_instance = api_instance
    global_dataset = dataset
    # import_json_partial = partial(import_json123, api_instance, dataset)
    pool = Pool(processes=processes)
    pool_output = pool.imap_unordered(_upload_file, file_iter)
    pool.close()
    pool.join()

    file_props = []
    for fp in pool_output:
        file_props.append(fp)

    return file_props


###############################################################################
#
# Import a single URL
#
def _upload_url(url):
    payload = nucleus_api.UploadURLModel(
        dataset=global_dataset,
        file_url=url
    )  # UploadURLModel |

    try:
        api_response = global_api_instance.post_upload_url(payload)
        return api_response.result
    except ApiException as e:
        print("Exception when calling DatasetsApi->post_upload_url: %s\n" % e)

#
# Import files into a dataset with parallel processes
# Inputs:
#     api_instance: handle to Nucleus API instance
#     dataset: name of the dataset
#     url_iters: iterable containing URLs
#     processes: number of parallel processes. Default=4
#
# Output:
#     list of URL properties (URL and size)
#
def upload_urls(api_instance, dataset, url_iter, processes=4):
    # partial() function not work well with pool, use global variables as a workaround
    global global_api_instance
    global global_dataset

    global_api_instance = api_instance
    global_dataset = dataset
    # import_json_partial = partial(import_json123, api_instance, dataset)
    pool = Pool(processes=processes)
    pool_output = pool.imap_unordered(_upload_url, url_iter)
    pool.close()
    pool.join()

    url_props = []
    for up in pool_output:
        url_props.append(up)

    return url_props


###############################################################################
#
# Summarize a file from URL
# * Create a temporary dataset
# * Run document summary API to generate the summary
# * Delete the temporary dataset
#
# file_params fields descriptions:
#   file_url              : string, the URL at which the file is stored (could be a S3 bucket address for instance)
#   filename              : OPTIONAL string, filename saved on the server. also serves as the doc_title for summarization
#   custom_stop_words     : OPTIONAL a string list, user-provided list of stopwords to be excluded from the content analysis leading to document summarization
#                            ["word1", "word2", ...]. DEFAULT: empty
#   summary_length        : OPTIONAL an integer, the maximum number of bullet points a user wants to see in the document summary. DEFAULT: 6
#   context_amount        : OPTIONAL an integer, the number of sentences surrounding key summary sentences in the original document that a user wants to see in the document summary. DEFAULT: 0
#   short_sentence_length : OPTIONAL an integer, the sentence length below which a sentence is excluded from summarization. DEFAULT: 4 words
#   long_sentence_length  : OPTIONAL an integer, the sentence length beyond which a sentence is excluded from summarization. DEFAULT: 40 words
#
def summarize_file_url(api_instance, file_params):
    # temporary and unique dataset name to be deleted after summarization is done
    dataset = 'summarize_url_' + str(uuid.uuid4())

    ############################################################################
    # create the dataset with URL
    payload = nucleus_api.UploadURLModel(
                dataset=dataset,
                file_url=file_params['file_url'],
                filename=file_params['filename']
            ) # UploadURLModel | 

    try:
        api_response = api_instance.post_upload_url(payload)
        #print(api_response)   # raw API response
    except ApiException as e:
        print("Exception when calling DatasetsApi->post_upload_url: %s\n" % e)
    
    
    ################################################################################
    # Get document summary
    try:
        payload = nucleus_api.DocumentSummaryModel(
            dataset=dataset,
            doc_title=file_params['filename'],
            custom_stop_words=file_params['custom_stop_words'],
            summary_length=file_params['summary_length'],
            context_amount=file_params['context_amount'],
            short_sentence_length=file_params['short_sentence_length'],
            long_sentence_length=file_params['long_sentence_length'])

        api_response = api_instance.post_doc_summary_api(payload)
        doc_summary_api_result = api_response.result
    
    except ApiException as e:
        print("Exception when calling DocumentsApi->get_doc_summary_api: %s\n" % e)
        return

    #################################################################################
    # delete the dataset
    payload = nucleus_api.DeleteDatasetModel(dataset=dataset)

    try:
        api_response = api_instance.post_delete_dataset(payload)
        #pprint(api_response)
    except ApiException as e:
        print("Exception when calling DatasetsApi->post_delete_dataset: %s\n" % e)
        return

    return doc_summary_api_result


###############################################################################
#
# Summarize a file from URL
# * Create a temporary dataset
# * Run document summary API to generate the summary
# * Delete the temporary dataset
#
# file_params fields descriptions:
#   file_url              : string, the URL at which the file is stored (could be a S3 bucket address for instance)
#   filename              : OPTIONAL string, filename saved on the server. also serves as the doc_title for summarization
#   custom_stop_words     : OPTIONAL a string list, user-provided list of stopwords to be excluded from the content analysis leading to document summarization
#                            ["word1", "word2", ...]. DEFAULT: empty
#   summary_length        : OPTIONAL an integer, the maximum number of bullet points a user wants to see in the document summary. DEFAULT: 6
#   context_amount        : OPTIONAL an integer, the number of sentences surrounding key summary sentences in the original document that a user wants to see in the document summary. DEFAULT: 0
#   short_sentence_length : OPTIONAL an integer, the sentence length below which a sentence is excluded from summarization. DEFAULT: 4 words
#   long_sentence_length  : OPTIONAL an integer, the sentence length beyond which a sentence is excluded from summarization. DEFAULT: 40 words
#
def summarize_file(api_instance, file_params):
    dataset = 'summarize_file_' + str(uuid.uuid4()) # to be deleted
    #print('summarize_file:', dataset)

    filename = file_params.get('filename', file_params['file'])
    try:
        api_response = api_instance.post_upload_file(file_params['file'],
                                                     dataset,
                                                     filename=filename)
        # print(api_response)   # raw API response
    except ApiException as e:
        print("Exception when calling DatasetsApi->post_upload_url: %s\n" % e)
        return None

    #print('filename=', filename)
    ################################################################################
    # Get document summary
    try:
        payload = nucleus_api.DocumentSummaryModel(
            dataset=dataset,
            doc_title=filename,
            custom_stop_words=file_params['custom_stop_words'],
            summary_length=file_params['summary_length'],
            context_amount=file_params['context_amount'],
            short_sentence_length=file_params['short_sentence_length'],
            long_sentence_length=file_params['long_sentence_length'])

        api_response = api_instance.post_doc_summary_api(payload)
        doc_summary_api_result = api_response.result

    except ApiException as e:
        print("Exception when calling DocumentsApi->get_doc_summary_api: %s\n" % e)
        return None

    #################################################################################
    # delete the dataset
    payload = nucleus_api.DeleteDatasetModel(dataset=dataset)

    try:
        api_response = api_instance.post_delete_dataset(payload)
        # pprint(api_response)
    except ApiException as e:
        print("Exception when calling DatasetsApi->post_delete_dataset: %s\n" % e)
        return None

    return doc_summary_api_result

#
# Plot topic historical analysis
#
# def topic_charts_historical(historical_metrics, selected_topics, show_sentiment_consensus):
#
#     # Charts of Strength, Sentiment, Consensus for each of the topics
#     current_max_strength = 0
#     current_max_sent = 0
#     current_max_cons = 0
#     for i in selected_topics:
#         if np.nanmax(np.abs(historical_metrics[i]['strength'])) > current_max_strength:
#             current_max_strength = np.nanmax(np.abs(historical_metrics[i]['strength']))
#         if np.nanmax(np.abs(historical_metrics[i]['sentiment'])) > current_max_sent:
#             current_max_sent = np.nanmax(np.abs(historical_metrics[i]['sentiment']))
#         if np.nanmax(np.abs(historical_metrics[i]['consensus'])) > current_max_cons:
#             current_max_cons = np.nanmax(np.abs(historical_metrics[i]['consensus']))
#
#     if show_sentiment_consensus == True:
#         plt.rcParams['figure.figsize'] = [12, 18*len(selected_topics)]
#         fig = plt.figure()
#         for i in selected_topics:
#             current_ax = 'ax' + str(selected_topics.index(i) + 1)
#             if current_ax == 'ax1':
#                 current_ax = plt.subplot(3*len(selected_topics), 1, 1 + 3*selected_topics.index(i))
#                 ax1 = plt.subplot(3*len(selected_topics), 1, 1 + 3*selected_topics.index(i))
#             else:
#                 current_ax = plt.subplot(3*len(selected_topics), 1, 1 + 3*selected_topics.index(i), sharex=ax1)
#
#             # 3 subplots, one per strength, sentiment, consensus
#             current_ax.set_ylim([0, 1.05*current_max_strength])
#             current_ax.plot('time_stamps', 'strength', data=historical_metrics[i], color='blue')
#             plt.ylabel('Prevalence', fontsize=14, fontweight="bold")
#             plt.title(historical_metrics[i]['topic'], fontsize=14, fontweight="bold")
#
#             current_axSent = plt.subplot(3*len(selected_topics), 1, 1 + 3*selected_topics.index(i) + 1, sharex=ax1)
#             current_axSent.set_ylim([-1.05*current_max_sent, 1.05*current_max_sent])
#             current_axSent.plot('time_stamps', 'sentiment', data=historical_metrics[i], color='green')
#             plt.ylabel('Sentiment', fontsize=14, fontweight="bold")
#
#             current_axCons = plt.subplot(3*len(selected_topics), 1, 1 + 3*selected_topics.index(i) + 2, sharex=ax1)
#             current_axCons.set_ylim([0, 1.05*current_max_cons])
#             current_axCons.plot('time_stamps', 'consensus', data=historical_metrics[i], color='red')
#             plt.ylabel('Consensus', fontsize=14, fontweight="bold")
#
#         fig.autofmt_xdate(rotation=90)
#     else:
#         plt.rcParams['figure.figsize'] = [12, 6*len(selected_topics)]
#         fig = plt.figure()
#         for i in selected_topics:
#             current_ax = 'ax' + str(selected_topics.index(i) + 1)
#             if current_ax == 'ax1':
#                 current_ax = plt.subplot(len(selected_topics), 1, selected_topics.index(i) + 1)
#                 ax1 = plt.subplot(len(selected_topics), 1, selected_topics.index(i) + 1)
#             else:
#                 current_ax = plt.subplot(len(selected_topics), 1, selected_topics.index(i) + 1, sharex=ax1)
#             current_ax.set_ylim([0, 1.05*current_max_strength])
#             current_ax.plot('time_stamps', 'strength', data=historical_metrics[i], color='blue')
#             plt.ylabel('Prevalence', fontsize=14, fontweight="bold")
#             plt.title(historical_metrics[i]['topic'], fontsize=14, fontweight="bold")
#         fig.autofmt_xdate(rotation=90)
#
#     return 0


################################################################################
# templates
################################################################################
class NucleusApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    # method to poll job status
    def poll_job_status(self, job_id):
        print('INFO: Start polling job status of', job_id)
        i = 0
        sleep_time = 2
        result = None
        while result is None:
            time.sleep(sleep_time)
            try:
                res = self.get_job(job_id)
            except:
                # ignore exception during polling
                # print('DEBUG: polling exception')
                continue

            result = res.result
            #print('DEBUG: poll_job_status after get_job i res=', res)
            if res.error is not None:
                print('Error:', res.error)
                raise ApiException(status='api_error', reason=res.error)

            i += sleep_time
            if i > 7200:
                print('Error: API timed out')
                return

            if i % 120 == 0:
                print('INFO: Job {} has been running for {} minutes'.format(job_id, i / 60))

        print('INFO: Job {} completed.'.format(job_id))
        return res


    def get_job(self, id, **kwargs):  # noqa: E501
        """get_job  # noqa: E501

        Use this API to check the progress and retrieve results of a job. Poll this endpoint repeatedly until result is not null.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID of the job (required)
        :return: JobRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_job_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_job  # noqa: E501

        Use this API to check the progress and retrieve results of a job. Poll this endpoint repeatedly until result is not null.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID of the job (required)
        :return: JobRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='JobRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def get_list_datasets(self, **kwargs):  # noqa: E501
        """get_list_datasets  # noqa: E501

        List the datasets owned by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_datasets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListDatasetsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_datasets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_list_datasets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_list_datasets_with_http_info(self, **kwargs):  # noqa: E501
        """get_list_datasets  # noqa: E501

        List the datasets owned by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_datasets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListDatasetsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_datasets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='ListDatasetsRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def get_list_filters(self, **kwargs):  # noqa: E501
        """get_list_filters  # noqa: E501

        List the filters owned by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_filters(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListFiltersModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_filters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_list_filters_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_list_filters_with_http_info(self, **kwargs):  # noqa: E501
        """get_list_filters  # noqa: E501

        List the filters owned by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_filters_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListFiltersModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_filters" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='ListFiltersModel'  # noqa: E501
        res = self.api_client.call_api(
            '/filters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def get_list_forensics(self, **kwargs):  # noqa: E501
        """get_list_forensics  # noqa: E501

        List forensic modules owned by the user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_forensics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListForensicsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_forensics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_list_forensics_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_list_forensics_with_http_info(self, **kwargs):  # noqa: E501
        """get_list_forensics  # noqa: E501

        List forensic modules owned by the user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_forensics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListForensicsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_forensics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='ListForensicsRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/forensics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def get_user(self, user_email, password, **kwargs):  # noqa: E501
        """get_user  # noqa: E501

        Use this API to authenticate. If the password is correct, returns the user details, including the user's api key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(user_email, password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_email: Email of the user to authenticate.  (required)
        :param str password: Plaintext password of the user to authenticate.  (required)
        :return: UserModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_with_http_info(user_email, password, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_with_http_info(user_email, password, **kwargs)  # noqa: E501
            return data

    def get_user_with_http_info(self, user_email, password, **kwargs):  # noqa: E501
        """get_user  # noqa: E501

        Use this API to authenticate. If the password is correct, returns the user details, including the user's api key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(user_email, password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_email: Email of the user to authenticate.  (required)
        :param str password: Plaintext password of the user to authenticate.  (required)
        :return: UserModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_email', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_email' is set
        if ('user_email' not in params or
                params['user_email'] is None):
            raise ValueError("Missing the required parameter `user_email` when calling `get_user`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_email' in params:
            query_params.append(('user_email', params['user_email']))  # noqa: E501
        if 'password' in params:
            query_params.append(('password', params['password']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_type='UserModel'  # noqa: E501
        res = self.api_client.call_api(
            '/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_admin_add_user(self, payload, **kwargs):  # noqa: E501
        """post_admin_add_user  # noqa: E501

        Add a new user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_add_user(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminAddUserModel payload: (required)
        :return: AdminAddUserRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_admin_add_user_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_admin_add_user_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_admin_add_user_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_admin_add_user  # noqa: E501

        Add a new user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_add_user_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminAddUserModel payload: (required)
        :return: AdminAddUserRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_admin_add_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_admin_add_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='AdminAddUserRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/admin/add_user', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_admin_delete_user(self, payload, **kwargs):  # noqa: E501
        """post_admin_delete_user  # noqa: E501

        Delete user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_delete_user(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminDeleteUserModel payload: (required)
        :return: AdminDeleteUserRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_admin_delete_user_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_admin_delete_user_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_admin_delete_user_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_admin_delete_user  # noqa: E501

        Delete user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_delete_user_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminDeleteUserModel payload: (required)
        :return: AdminDeleteUserRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_admin_delete_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_admin_delete_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='AdminDeleteUserRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/admin/delete_user', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_admin_list(self, payload, **kwargs):  # noqa: E501
        """post_admin_list  # noqa: E501

        List users, datasets, resources, etc  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_list(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminListModel payload: (required)
        :return: AdminListRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_admin_list_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_admin_list_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_admin_list_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_admin_list  # noqa: E501

        List users, datasets, resources, etc  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_list_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminListModel payload: (required)
        :return: AdminListRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_admin_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_admin_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='AdminListRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/admin/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_admin_manage_dataset(self, payload, **kwargs):  # noqa: E501
        """post_admin_manage_dataset  # noqa: E501

        Manage a dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_manage_dataset(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminManageDatasetModel payload: (required)
        :return: AdminManageDatasetRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_admin_manage_dataset_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_admin_manage_dataset_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_admin_manage_dataset_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_admin_manage_dataset  # noqa: E501

        Manage a dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_manage_dataset_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminManageDatasetModel payload: (required)
        :return: AdminManageDatasetRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_admin_manage_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_admin_manage_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='AdminManageDatasetRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/admin/manage_dataset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_admin_update_user(self, payload, **kwargs):  # noqa: E501
        """post_admin_update_user  # noqa: E501

        Update information for a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_update_user(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminUpdateUserModel payload: (required)
        :return: AdminUpdateUserRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_admin_update_user_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_admin_update_user_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_admin_update_user_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_admin_update_user  # noqa: E501

        Update information for a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_admin_update_user_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminUpdateUserModel payload: (required)
        :return: AdminUpdateUserRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_admin_update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_admin_update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='AdminUpdateUserRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/admin/update_user', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_append_json_to_dataset(self, payload, **kwargs):  # noqa: E501
        """post_append_json_to_dataset  # noqa: E501

        Add a document to a dataset, in JSON form.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_append_json_to_dataset(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Appendjsonparams payload: (required)
        :return: AppendJsonRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_append_json_to_dataset_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_append_json_to_dataset_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_append_json_to_dataset_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_append_json_to_dataset  # noqa: E501

        Add a document to a dataset, in JSON form.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_append_json_to_dataset_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Appendjsonparams payload: (required)
        :return: AppendJsonRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_append_json_to_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_append_json_to_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='AppendJsonRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/append_json_to_dataset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_author_connectivity_api(self, payload, **kwargs):  # noqa: E501
        """post_author_connectivity_api  # noqa: E501

        Get the network of similar authors to a reference author.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_author_connectivity_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AuthorConnection payload: (required)
        :return: AuthorConnectRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_author_connectivity_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_author_connectivity_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_author_connectivity_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_author_connectivity_api  # noqa: E501

        Get the network of similar authors to a reference author.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_author_connectivity_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AuthorConnection payload: (required)
        :return: AuthorConnectRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_author_connectivity_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_author_connectivity_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='AuthorConnectRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/author_connectivity', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_available_sec_filings(self, payload, **kwargs):  # noqa: E501
        """post_available_sec_filings  # noqa: E501

        Get information about the available sec filings. If no input is passed, returns the list of all available tickers. If tickers are passed, returns the list of available document types for these tickers. If document types are also passed, returns the list of available sections for the selected tickers/filing types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_available_sec_filings(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EdgarFields payload: (required)
        :return: AvailableFilingsResponseModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_available_sec_filings_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_available_sec_filings_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_available_sec_filings_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_available_sec_filings  # noqa: E501

        Get information about the available sec filings. If no input is passed, returns the list of all available tickers. If tickers are passed, returns the list of available document types for these tickers. If document types are also passed, returns the list of available sections for the selected tickers/filing types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_available_sec_filings_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EdgarFields payload: (required)
        :return: AvailableFilingsResponseModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_available_sec_filings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_available_sec_filings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='AvailableFilingsResponseModel'  # noqa: E501
        res = self.api_client.call_api(
            '/feeds/available_sec_filings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_bulk_insert_json(self, payload, **kwargs):  # noqa: E501
        """post_bulk_insert_json  # noqa: E501

        Add many documents to a dataset, in JSON form. Bulk insertion is much faster than making one API call for each document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_bulk_insert_json(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BulkInsertParams payload: (required)
        :return: BulkInsertRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_bulk_insert_json_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_bulk_insert_json_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_bulk_insert_json_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_bulk_insert_json  # noqa: E501

        Add many documents to a dataset, in JSON form. Bulk insertion is much faster than making one API call for each document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_bulk_insert_json_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BulkInsertParams payload: (required)
        :return: BulkInsertRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_bulk_insert_json" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_bulk_insert_json`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='BulkInsertRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/bulk_insert_json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_create_dataset_from_sec_filings(self, payload, **kwargs):  # noqa: E501
        """post_create_dataset_from_sec_filings  # noqa: E501

        Creates a new dataset and populates it with sec filings matching the specified tickers/form types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_create_dataset_from_sec_filings(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EdgarQuery payload: (required)
        :return: CreateSecDatasetResponseModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_create_dataset_from_sec_filings_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_create_dataset_from_sec_filings_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_create_dataset_from_sec_filings_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_create_dataset_from_sec_filings  # noqa: E501

        Creates a new dataset and populates it with sec filings matching the specified tickers/form types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_create_dataset_from_sec_filings_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EdgarQuery payload: (required)
        :return: CreateSecDatasetResponseModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_create_dataset_from_sec_filings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_create_dataset_from_sec_filings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='CreateSecDatasetResponseModel'  # noqa: E501
        res = self.api_client.call_api(
            '/feeds/create_dataset_from_sec_filings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_custom_tracker_api(self, payload, **kwargs):  # noqa: E501
        """post_custom_tracker_api  # noqa: E501

        Get custom tracker on chosen dataset and queries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_custom_tracker_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CustomTrackerModel payload: (required)
        :return: CustomTrackerRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_custom_tracker_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_custom_tracker_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_custom_tracker_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_custom_tracker_api  # noqa: E501

        Get custom tracker on chosen dataset and queries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_custom_tracker_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CustomTrackerModel payload: (required)
        :return: CustomTrackerRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_custom_tracker_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_custom_tracker_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='CustomTrackerRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/dashboard/custom_tracker', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_dataset_info(self, payload, **kwargs):  # noqa: E501
        """post_dataset_info  # noqa: E501

        Get information about a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_dataset_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DatasetInfo payload: (required)
        :return: DatasetInfoRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_dataset_info_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_dataset_info_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_dataset_info_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_dataset_info  # noqa: E501

        Get information about a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_dataset_info_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DatasetInfo payload: (required)
        :return: DatasetInfoRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_dataset_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_dataset_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DatasetInfoRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/dataset_info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_dataset_tagging(self, payload, **kwargs):  # noqa: E501
        """post_dataset_tagging  # noqa: E501

        Tag documents containig specified entities within a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_dataset_tagging(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DatasetTagging payload: (required)
        :return: DatasetTaggingRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_dataset_tagging_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_dataset_tagging_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_dataset_tagging_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_dataset_tagging  # noqa: E501

        Tag documents containig specified entities within a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_dataset_tagging_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DatasetTagging payload: (required)
        :return: DatasetTaggingRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_dataset_tagging" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_dataset_tagging`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DatasetTaggingRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/dataset_tagging', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_delete_dataset(self, payload, **kwargs):  # noqa: E501
        """post_delete_dataset  # noqa: E501

        Delete an existing dataset from the user storage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_delete_dataset(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteDatasetModel payload: (required)
        :return: DeleteDatasetRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_delete_dataset_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_delete_dataset_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_delete_dataset_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_delete_dataset  # noqa: E501

        Delete an existing dataset from the user storage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_delete_dataset_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteDatasetModel payload: (required)
        :return: DeleteDatasetRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_delete_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_delete_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DeleteDatasetRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/delete_dataset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_delete_document(self, payload, **kwargs):  # noqa: E501
        """post_delete_document  # noqa: E501

        Delete documents from a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_delete_document(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteDocumentModel payload: (required)
        :return: DeleteDocumentRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_delete_document_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_delete_document_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_delete_document_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_delete_document  # noqa: E501

        Delete documents from a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_delete_document_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteDocumentModel payload: (required)
        :return: DeleteDocumentRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_delete_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_delete_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DeleteDocumentRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/delete_document', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_delete_filter(self, payload, **kwargs):  # noqa: E501
        """post_delete_filter  # noqa: E501

        Delete a filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_delete_filter(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteFilterModel payload: (required)
        :return: DeleteFilterRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_delete_filter_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_delete_filter_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_delete_filter_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_delete_filter  # noqa: E501

        Delete a filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_delete_filter_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteFilterModel payload: (required)
        :return: DeleteFilterRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_delete_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_delete_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DeleteFilterRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/filters/delete_filter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_delete_forensic(self, payload, **kwargs):  # noqa: E501
        """post_delete_forensic  # noqa: E501

        Delete forensic module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_delete_forensic(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteForensicModel payload: (required)
        :return: DeleteForensicRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_delete_forensic_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_delete_forensic_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_delete_forensic_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_delete_forensic  # noqa: E501

        Delete forensic module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_delete_forensic_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteForensicModel payload: (required)
        :return: DeleteForensicRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_delete_forensic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_delete_forensic`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DeleteForensicRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/forensics/delete_forensic', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_doc_classify_api(self, payload, **kwargs):  # noqa: E501
        """post_doc_classify_api  # noqa: E501

        Document one-layer classifier on a chosen dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_classify_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocClassifyModel payload: (required)
        :return: DocClassifyRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_doc_classify_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_doc_classify_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_doc_classify_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_classify_api  # noqa: E501

        Document one-layer classifier on a chosen dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_classify_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocClassifyModel payload: (required)
        :return: DocClassifyRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_doc_classify_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_doc_classify_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocClassifyRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_classify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_doc_display(self, payload, **kwargs):  # noqa: E501
        """post_doc_display  # noqa: E501

        Document display.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_display(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocDisplay payload: (required)
        :return: DocDisplayRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_doc_display_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_doc_display_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_doc_display_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_display  # noqa: E501

        Document display.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_display_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocDisplay payload: (required)
        :return: DocDisplayRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_doc_display" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_doc_display`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocDisplayRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_display', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_doc_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_info  # noqa: E501

        Retrieve metadata of documents matching the provided filter (limited to 10000 documents).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocInfo payload: (required)
        :return: DocInfoRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_doc_info_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_doc_info_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_doc_info_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_info  # noqa: E501

        Retrieve metadata of documents matching the provided filter (limited to 10000 documents).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_info_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocInfo payload: (required)
        :return: DocInfoRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_doc_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_doc_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocInfoRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_doc_new_words_api(self, payload, **kwargs):  # noqa: E501
        """post_doc_new_words_api  # noqa: E501

        Document new words.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_new_words_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentNewWordsModel payload: (required)
        :return: DocumentNewWordsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_doc_new_words_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_doc_new_words_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_doc_new_words_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_new_words_api  # noqa: E501

        Document new words.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_new_words_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentNewWordsModel payload: (required)
        :return: DocumentNewWordsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_doc_new_words_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_doc_new_words_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocumentNewWordsRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_new_words', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_doc_novelty_api(self, payload, **kwargs):  # noqa: E501
        """post_doc_novelty_api  # noqa: E501

        Document novelty.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_novelty_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentNoveltyModel payload: (required)
        :return: DocumentNoveltyRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_doc_novelty_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_doc_novelty_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_doc_novelty_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_novelty_api  # noqa: E501

        Document novelty.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_novelty_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentNoveltyModel payload: (required)
        :return: DocumentNoveltyRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_doc_novelty_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_doc_novelty_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocumentNoveltyRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_novelty', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_doc_recommend_api(self, payload, **kwargs):  # noqa: E501
        """post_doc_recommend_api  # noqa: E501

        Recommendation of documents on given topics that have been extracted from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_recommend_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentRecommendModel payload: (required)
        :return: DocumentRecommendRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_doc_recommend_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_doc_recommend_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_doc_recommend_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_recommend_api  # noqa: E501

        Recommendation of documents on given topics that have been extracted from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_recommend_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentRecommendModel payload: (required)
        :return: DocumentRecommendRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_doc_recommend_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_doc_recommend_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocumentRecommendRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_recommend', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_doc_sentiment_api(self, payload, **kwargs):  # noqa: E501
        """post_doc_sentiment_api  # noqa: E501

        Document sentiment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_sentiment_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentSentimentModel payload: (required)
        :return: DocumentSentimentRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_doc_sentiment_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_doc_sentiment_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_doc_sentiment_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_sentiment_api  # noqa: E501

        Document sentiment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_sentiment_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentSentimentModel payload: (required)
        :return: DocumentSentimentRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_doc_sentiment_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_doc_sentiment_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocumentSentimentRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_sentiment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_doc_summary_api(self, payload, **kwargs):  # noqa: E501
        """post_doc_summary_api  # noqa: E501

        Document summarization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_summary_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentSummaryModel payload: (required)
        :return: DocumentSummaryRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_doc_summary_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_doc_summary_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_doc_summary_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_doc_summary_api  # noqa: E501

        Document summarization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_doc_summary_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentSummaryModel payload: (required)
        :return: DocumentSummaryRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_doc_summary_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_doc_summary_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocumentSummaryRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_summary', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_document_contrast_summary_api(self, payload, **kwargs):  # noqa: E501
        """post_document_contrast_summary_api  # noqa: E501

        Document contrasted summarization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_document_contrast_summary_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentContrastSummaryModel payload: (required)
        :return: DocumentContrastSummaryRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_document_contrast_summary_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_document_contrast_summary_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_document_contrast_summary_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_document_contrast_summary_api  # noqa: E501

        Document contrasted summarization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_document_contrast_summary_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentContrastSummaryModel payload: (required)
        :return: DocumentContrastSummaryRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_document_contrast_summary_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_document_contrast_summary_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='DocumentContrastSummaryRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/documents/document_contrasted_summary', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_example_job(self, color, wait_time, **kwargs):  # noqa: E501
        """post_example_job  # noqa: E501

        Start an example background job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_example_job(color, wait_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str color: A color (required)
        :param int wait_time: Seconds to wait before returning the result (required)
        :return: ExampleJobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_example_job_with_http_info(color, wait_time, **kwargs)  # noqa: E501
        else:
            (data) = self.post_example_job_with_http_info(color, wait_time, **kwargs)  # noqa: E501
            return data

    def post_example_job_with_http_info(self, color, wait_time, **kwargs):  # noqa: E501
        """post_example_job  # noqa: E501

        Start an example background job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_example_job_with_http_info(color, wait_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str color: A color (required)
        :param int wait_time: Seconds to wait before returning the result (required)
        :return: ExampleJobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['color', 'wait_time']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_example_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'color' is set
        if ('color' not in params or
                params['color'] is None):
            raise ValueError("Missing the required parameter `color` when calling `post_example_job`")  # noqa: E501
        # verify the required parameter 'wait_time' is set
        if ('wait_time' not in params or
                params['wait_time'] is None):
            raise ValueError("Missing the required parameter `wait_time` when calling `post_example_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'color' in params:
            query_params.append(('color', params['color']))  # noqa: E501
        if 'wait_time' in params:
            query_params.append(('wait_time', params['wait_time']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='ExampleJobResponse'  # noqa: E501
        res = self.api_client.call_api(
            '/jobs/start_example_job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_key_authors_api(self, payload, **kwargs):  # noqa: E501
        """post_key_authors_api  # noqa: E501

        Get key authors on chosen dataset and queries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_key_authors_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param KeyAuthorsModel payload: (required)
        :return: KeyAuthorsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_key_authors_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_key_authors_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_key_authors_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_key_authors_api  # noqa: E501

        Get key authors on chosen dataset and queries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_key_authors_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param KeyAuthorsModel payload: (required)
        :return: KeyAuthorsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_key_authors_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_key_authors_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='KeyAuthorsRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/dashboard/key_authors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_legacy(self, payload, **kwargs):  # noqa: E501
        """post_legacy  # noqa: E501

        Recommendation of documents on given topics that have been extracted from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_legacy(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiCall payload: (required)
        :return: LegacyResponseModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_legacy_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_legacy_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_legacy_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_legacy  # noqa: E501

        Recommendation of documents on given topics that have been extracted from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_legacy_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiCall payload: (required)
        :return: LegacyResponseModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_legacy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_legacy`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='LegacyResponseModel'  # noqa: E501
        res = self.api_client.call_api(
            '/legacy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_metadata_autocomplete(self, payload, **kwargs):  # noqa: E501
        """post_metadata_autocomplete  # noqa: E501

        Retrieve available values for a certain metadata column, matching a query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_metadata_autocomplete(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataAutocomplete payload: (required)
        :return: MetadataAutocompleteRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_metadata_autocomplete_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_metadata_autocomplete_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_metadata_autocomplete_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_metadata_autocomplete  # noqa: E501

        Retrieve available values for a certain metadata column, matching a query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_metadata_autocomplete_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataAutocomplete payload: (required)
        :return: MetadataAutocompleteRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_metadata_autocomplete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_metadata_autocomplete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='MetadataAutocompleteRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/metadata_autocomplete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_metadata_histogram(self, payload, **kwargs):  # noqa: E501
        """post_metadata_histogram  # noqa: E501

        Return document count for each distinct value of the given metadata column.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_metadata_histogram(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataHistogram payload: (required)
        :return: MetadataHistogramRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_metadata_histogram_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_metadata_histogram_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_metadata_histogram_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_metadata_histogram  # noqa: E501

        Return document count for each distinct value of the given metadata column.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_metadata_histogram_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataHistogram payload: (required)
        :return: MetadataHistogramRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_metadata_histogram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_metadata_histogram`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='MetadataHistogramRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/metadata_histogram', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_rename_dataset(self, payload, **kwargs):  # noqa: E501
        """post_rename_dataset  # noqa: E501

        Rename an existing dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_rename_dataset(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RenameDatasetModel payload: (required)
        :return: RenameDatasetRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_rename_dataset_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_rename_dataset_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_rename_dataset_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_rename_dataset  # noqa: E501

        Rename an existing dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_rename_dataset_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RenameDatasetModel payload: (required)
        :return: RenameDatasetRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_rename_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_rename_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='RenameDatasetRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/rename_dataset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_save_filter(self, payload, **kwargs):  # noqa: E501
        """post_save_filter  # noqa: E501

        Save a filter representing a subset of a dataset (time range, query, metadata..).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_save_filter(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SaveFilterModel payload: (required)
        :return: SaveFilterRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_save_filter_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_save_filter_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_save_filter_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_save_filter  # noqa: E501

        Save a filter representing a subset of a dataset (time range, query, metadata..).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_save_filter_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SaveFilterModel payload: (required)
        :return: SaveFilterRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_save_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_save_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='SaveFilterRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/filters/save_filter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_save_forensic(self, payload, **kwargs):  # noqa: E501
        """post_save_forensic  # noqa: E501

        Save forensic module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_save_forensic(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ForensicModel payload: (required)
        :return: SaveForensicRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_save_forensic_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_save_forensic_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_save_forensic_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_save_forensic  # noqa: E501

        Save forensic module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_save_forensic_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ForensicModel payload: (required)
        :return: SaveForensicRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_save_forensic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_save_forensic`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='SaveForensicRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/forensics/save_forensic', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_setup_connector(self, payload, **kwargs):  # noqa: E501
        """post_setup_connector  # noqa: E501

        Set up a connector to regularly ingest data into the specified dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_setup_connector(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetupConnectorModel payload: (required)
        :return: SetupConnectorRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_setup_connector_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_setup_connector_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_setup_connector_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_setup_connector  # noqa: E501

        Set up a connector to regularly ingest data into the specified dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_setup_connector_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetupConnectorModel payload: (required)
        :return: SetupConnectorRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_setup_connector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_setup_connector`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='SetupConnectorRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/connectors/setup_connector', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_smart_alerts_api(self, payload, **kwargs):  # noqa: E501
        """post_smart_alerts_api  # noqa: E501

        Get smart alerts on chosen dataset and queries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_smart_alerts_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SmartAlertsModel payload: (required)
        :return: SmartAlertsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_smart_alerts_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_smart_alerts_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_smart_alerts_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_smart_alerts_api  # noqa: E501

        Get smart alerts on chosen dataset and queries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_smart_alerts_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SmartAlertsModel payload: (required)
        :return: SmartAlertsRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_smart_alerts_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_smart_alerts_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='SmartAlertsRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/dashboard/smart_alerts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_api  # noqa: E501

        Get key topics from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Topics payload: (required)
        :return: TopicRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_api  # noqa: E501

        Get key topics from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Topics payload: (required)
        :return: TopicRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_consensus_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_consensus_api  # noqa: E501

        Get topic consensus for topics extracted from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_consensus_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicConsensusModel payload: (required)
        :return: TopicConsensusRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_consensus_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_consensus_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_consensus_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_consensus_api  # noqa: E501

        Get topic consensus for topics extracted from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_consensus_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicConsensusModel payload: (required)
        :return: TopicConsensusRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_consensus_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_consensus_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicConsensusRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_consensus', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_consensus_transfer_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_consensus_transfer_api  # noqa: E501

        Get exposures of documents in a validation dataset to topics extracted from a reference dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_consensus_transfer_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicConsensusTransferModel payload: (required)
        :return: TopicConsensusTransferRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_consensus_transfer_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_consensus_transfer_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_consensus_transfer_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_consensus_transfer_api  # noqa: E501

        Get exposures of documents in a validation dataset to topics extracted from a reference dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_consensus_transfer_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicConsensusTransferModel payload: (required)
        :return: TopicConsensusTransferRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_consensus_transfer_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_consensus_transfer_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicConsensusTransferRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_consensus_transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_contrast_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_contrast_api  # noqa: E501

        Contrasting topic extraction on a chosen dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_contrast_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicContrastModel payload: (required)
        :return: TopicContrastRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_contrast_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_contrast_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_contrast_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_contrast_api  # noqa: E501

        Contrasting topic extraction on a chosen dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_contrast_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicContrastModel payload: (required)
        :return: TopicContrastRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_contrast_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_contrast_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicContrastRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_contrast', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_delta_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_delta_api  # noqa: E501

        Get changes in exposure to key topics from documents in a dataset in between two dates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_delta_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicDeltaModel payload: (required)
        :return: TopicDeltaRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_delta_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_delta_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_delta_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_delta_api  # noqa: E501

        Get changes in exposure to key topics from documents in a dataset in between two dates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_delta_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicDeltaModel payload: (required)
        :return: TopicDeltaRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_delta_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_delta_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicDeltaRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_delta', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_historical_analysis_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_historical_analysis_api  # noqa: E501

        Get a historical analysis of topics extracted from a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_historical_analysis_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicHistoryModel payload: (required)
        :return: TopicHistoryRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_historical_analysis_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_historical_analysis_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_historical_analysis_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_historical_analysis_api  # noqa: E501

        Get a historical analysis of topics extracted from a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_historical_analysis_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicHistoryModel payload: (required)
        :return: TopicHistoryRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_historical_analysis_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_historical_analysis_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicHistoryRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_historical', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_sentiment_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_sentiment_api  # noqa: E501

        Get topic sentiment for topics extracted from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_sentiment_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicSentimentModel payload: (required)
        :return: TopicSentimentRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_sentiment_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_sentiment_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_sentiment_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_sentiment_api  # noqa: E501

        Get topic sentiment for topics extracted from a given dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_sentiment_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicSentimentModel payload: (required)
        :return: TopicSentimentRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_sentiment_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_sentiment_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicSentimentRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_sentiment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_sentiment_transfer_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_sentiment_transfer_api  # noqa: E501

        Get sentiment exposures of documents in a validation dataset to topics extracted from a reference dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_sentiment_transfer_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicSentimentTransferModel payload: (required)
        :return: TopicSentimentTransferRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_sentiment_transfer_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_sentiment_transfer_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_sentiment_transfer_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_sentiment_transfer_api  # noqa: E501

        Get sentiment exposures of documents in a validation dataset to topics extracted from a reference dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_sentiment_transfer_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicSentimentTransferModel payload: (required)
        :return: TopicSentimentTransferRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_sentiment_transfer_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_sentiment_transfer_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicSentimentTransferRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_sentiment_transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_summary_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_summary_api  # noqa: E501

        Get summaries of topics that have been extracted from a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_summary_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicSummaryModel payload: (required)
        :return: TopicSummaryRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_summary_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_summary_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_summary_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_summary_api  # noqa: E501

        Get summaries of topics that have been extracted from a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_summary_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicSummaryModel payload: (required)
        :return: TopicSummaryRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_summary_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_summary_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicSummaryRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_summary', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_topic_transfer_api(self, payload, **kwargs):  # noqa: E501
        """post_topic_transfer_api  # noqa: E501

        Get exposures of documents in a validation dataset to topics extracted from a reference dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_transfer_api(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicTransferModel payload: (required)
        :return: TopicTransferRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_topic_transfer_api_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_topic_transfer_api_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_topic_transfer_api_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_topic_transfer_api  # noqa: E501

        Get exposures of documents in a validation dataset to topics extracted from a reference dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_topic_transfer_api_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopicTransferModel payload: (required)
        :return: TopicTransferRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_topic_transfer_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_topic_transfer_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='TopicTransferRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/topics/topic_transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_update_dataset_metadata(self, payload, **kwargs):  # noqa: E501
        """post_update_dataset_metadata  # noqa: E501

        Update dataset metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_update_dataset_metadata(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateDatasetMetadataModel payload: (required)
        :return: UpdateDatasetMetadataRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_update_dataset_metadata_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_update_dataset_metadata_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_update_dataset_metadata_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_update_dataset_metadata  # noqa: E501

        Update dataset metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_update_dataset_metadata_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateDatasetMetadataModel payload: (required)
        :return: UpdateDatasetMetadataRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_update_dataset_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_update_dataset_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='UpdateDatasetMetadataRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/update_dataset_metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_update_forensic(self, payload, **kwargs):  # noqa: E501
        """post_update_forensic  # noqa: E501

        Update forensic module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_update_forensic(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateForensicModel payload: (required)
        :return: SaveForensicRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_update_forensic_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_update_forensic_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_update_forensic_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_update_forensic  # noqa: E501

        Update forensic module  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_update_forensic_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateForensicModel payload: (required)
        :return: SaveForensicRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_update_forensic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_update_forensic`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='SaveForensicRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/forensics/update_forensic', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_upload_file(self, file, dataset, **kwargs):  # noqa: E501
        """post_upload_file  # noqa: E501

        Upload a file to the specified dataset. If the dataset does not exist, it will be created. The \"ngram\" setting for the dataset can be specified with \"metadata.tokenization_ngram\". e.g. metadata = {\"tokenization_ngram\": 1}. If the dataset exists, the file will be appended to it. <br />If the file extension is .csv, .tsv, .xls, or .xlsx, it must contain column headers \"title\", \"content\" and \"time\". Each row in the spreadsheet will be processed as a single document. <br />Otherwise, the file will be processed as a single document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_upload_file(file, dataset, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: File to be uploaded (required)
        :param str dataset: Dataset name (required)
        :param str filename: Specify the filename if you want to override the original filename.Nucleus guesses the file type from the file name extension.
        :param str time: Document publication time
        :param str metadata: JSON containing document metadata(e.g. {\"author\": author, \"time\": \"2020-01-01\"}. Metadata values are case-sensitive.
        :param str dateformat: Specify the date format in the document to help date parsing. For example, if the date is \"Tue Jun 12 00:30:00 +0000 2018\", set dateformat to \"%a %b %d %H:%M:%S %z %Y\". If dateformat is not set, Nucleus guesses the date format with different methods.
        :return: UploadFileRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_upload_file_with_http_info(file, dataset, **kwargs)  # noqa: E501
        else:
            (data) = self.post_upload_file_with_http_info(file, dataset, **kwargs)  # noqa: E501
            return data

    def post_upload_file_with_http_info(self, file, dataset, **kwargs):  # noqa: E501
        """post_upload_file  # noqa: E501

        Upload a file to the specified dataset. If the dataset does not exist, it will be created. The \"ngram\" setting for the dataset can be specified with \"metadata.tokenization_ngram\". e.g. metadata = {\"tokenization_ngram\": 1}. If the dataset exists, the file will be appended to it. <br />If the file extension is .csv, .tsv, .xls, or .xlsx, it must contain column headers \"title\", \"content\" and \"time\". Each row in the spreadsheet will be processed as a single document. <br />Otherwise, the file will be processed as a single document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_upload_file_with_http_info(file, dataset, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: File to be uploaded (required)
        :param str dataset: Dataset name (required)
        :param str filename: Specify the filename if you want to override the original filename.Nucleus guesses the file type from the file name extension.
        :param str time: Document publication time
        :param str metadata: JSON containing document metadata(e.g. {\"author\": author, \"time\": \"2020-01-01\"}. Metadata values are case-sensitive.
        :param str dateformat: Specify the date format in the document to help date parsing. For example, if the date is \"Tue Jun 12 00:30:00 +0000 2018\", set dateformat to \"%a %b %d %H:%M:%S %z %Y\". If dateformat is not set, Nucleus guesses the date format with different methods.
        :return: UploadFileRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'dataset', 'filename', 'time', 'metadata', 'dateformat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_upload_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `post_upload_file`")  # noqa: E501
        # verify the required parameter 'dataset' is set
        if ('dataset' not in params or
                params['dataset'] is None):
            raise ValueError("Missing the required parameter `dataset` when calling `post_upload_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dataset' in params:
            query_params.append(('dataset', params['dataset']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'time' in params:
            query_params.append(('time', params['time']))  # noqa: E501
        if 'metadata' in params:
            query_params.append(('metadata', params['metadata']))  # noqa: E501
        if 'dateformat' in params:
            query_params.append(('dateformat', params['dateformat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='UploadFileRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/upload_file', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res


    def post_upload_url(self, payload, **kwargs):  # noqa: E501
        """post_upload_url  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_upload_url(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UploadURLModel payload: (required)
        :return: UploadUrlRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_upload_url_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_upload_url_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_upload_url_with_http_info(self, payload, **kwargs):  # noqa: E501
        """post_upload_url  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_upload_url_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UploadURLModel payload: (required)
        :return: UploadUrlRespModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_upload_url" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_upload_url`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apikey']  # noqa: E501

        response_type='UploadUrlRespModel'  # noqa: E501
        res = self.api_client.call_api(
            '/datasets/upload_url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=response_type,
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

        #print('call-api res=', res)
        job_id = res.job_id
        if job_id is None or job_id == '':
            pass
        else:
            if res.result is None and response_type != 'JobRespModel':
                # make sure only poll job status when the api is not get_job
                # to avoid maximum recursion limit error
                res = self.poll_job_status(job_id)

                # When API finishes before the polling wait time, the return is
                # expected API response type
                # When API is polled, the return type is JobRespModel. Needs to
                # convert it back to the expected API response type
                # print('expected res type=', response_type)
                if (res.result != None and
                    isinstance(res, nucleus_api.models.job_resp_model.JobRespModel) and
                    response_type != 'JobRespModel'):

                    res_conv = {"job_id": res.job_id, "result": json.loads(res.result)}
                    res = self.api_client.deserialize_result(res_conv, response_type)


        return res

