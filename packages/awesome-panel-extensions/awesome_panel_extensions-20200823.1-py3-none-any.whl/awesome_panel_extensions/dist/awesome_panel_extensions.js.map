{"version":3,"sources":["@@\\awesome_panel_extensions\\dist\\lib\\index.js","@@\\awesome_panel_extensions\\dist\\lib\\bokeh_extensions\\index.js","@@\\awesome_panel_extensions\\dist\\lib\\bokeh_extensions\\web_component.js","@@\\awesome_panel_extensions\\dist\\lib\\bokeh_extensions\\tabulator_model.js","@@\\awesome_panel_extensions\\dist\\lib\\bokeh_extensions\\perspective_viewer.js","@@\\awesome_panel_extensions\\dist\\lib\\bokeh_extensions\\shared.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(\"tslib\");\r\n    const AwesomePanelExtensions = tslib_1.__importStar(require(\"318e14e5ba\") /* ./bokeh_extensions */);\r\n    exports.AwesomePanelExtensions = AwesomePanelExtensions;\r\n    const base_1 = require(\"@bokehjs/base\");\r\n    base_1.register_models(AwesomePanelExtensions);\r\n}\r\n","/* bokeh_extensions\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var web_component_1 = require(\"5c604c9068\") /* ./web_component */;\r\n    exports.WebComponent = web_component_1.WebComponent;\r\n    var tabulator_model_1 = require(\"e2e34597ee\") /* ./tabulator_model */;\r\n    exports.TabulatorModel = tabulator_model_1.TabulatorModel;\r\n    var perspective_viewer_1 = require(\"59f7dfa54f\") /* ./perspective_viewer */;\r\n    exports.PerspectiveViewer = perspective_viewer_1.PerspectiveViewer;\r\n}\r\n","/* bokeh_extensions\\web_component.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(\"tslib\");\r\n    const dom_1 = require(\"@bokehjs/core/dom\");\r\n    const p = tslib_1.__importStar(require(\"@bokehjs/core/properties\"));\r\n    const html_box_1 = require(\"@bokehjs/models/layouts/html_box\");\r\n    const inputs_1 = require(\"@bokehjs/styles/widgets/inputs\");\r\n    function htmlDecode(input) {\r\n        var doc = new DOMParser().parseFromString(input, \"text/html\");\r\n        return doc.documentElement.textContent;\r\n    }\r\n    class WebComponentView extends html_box_1.HTMLBoxView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.name.change, () => this.handleNameChange());\r\n            this.connect(this.model.properties.innerHTML.change, () => this.render());\r\n            this.connect(this.model.properties.attributesLastChange.change, () => this.handleAttributesLastChangeChange());\r\n            this.connect(this.model.properties.propertiesLastChange.change, () => this.handlePropertiesLastChangeChange());\r\n            this.connect(this.model.properties.columnDataSource.change, () => this.handleColumnDataSourceChange());\r\n        }\r\n        handleNameChange() {\r\n            if (this.label_el)\r\n                this.label_el.textContent = this.model.name;\r\n        }\r\n        render() {\r\n            super.render();\r\n            if (this.el.innerHTML !== this.model.innerHTML)\r\n                this.createOrUpdateWebComponentElement();\r\n        }\r\n        after_layout() {\r\n            if (\"after_layout\" in this.webComponentElement)\r\n                this.webComponentElement.after_layout();\r\n        }\r\n        createOrUpdateWebComponentElement() {\r\n            if (this.webComponentElement)\r\n                this.webComponentElement.onchange = null;\r\n            // @Philippfr: How do we make sure the component is automatically sized according to the\r\n            // parameters of the WebComponent like width, height, sizing_mode etc?\r\n            // Should we set height and width to 100% or similar?\r\n            // For now I've set min_height as a part of .py __init__ for some of the Wired components?\r\n            const title = this.model.name;\r\n            if (this.model.componentType === \"inputgroup\" && title) {\r\n                this.group_el = dom_1.div({ class: inputs_1.bk_input_group }, this.label_el);\r\n                this.group_el.innerHTML = htmlDecode(this.model.innerHTML);\r\n                this.webComponentElement = this.group_el.firstElementChild;\r\n                this.label_el = dom_1.label({ style: { display: title.length == 0 ? \"none\" : \"\" } }, title);\r\n                this.group_el.insertBefore(this.label_el, this.webComponentElement);\r\n                this.el.appendChild(this.group_el);\r\n            }\r\n            else {\r\n                this.el.innerHTML = htmlDecode(this.model.innerHTML);\r\n                this.webComponentElement = this.el.firstElementChild;\r\n            }\r\n            this.activate_scripts(this.webComponentElement.parentNode);\r\n            // Initialize properties\r\n            this.initPropertyValues();\r\n            this.handlePropertiesLastChangeChange();\r\n            this.handleColumnDataSourceChange();\r\n            // Subscribe to events\r\n            this.webComponentElement.onchange = (ev) => this.handlePropertiesChange(ev);\r\n            this.addEventListeners();\r\n            this.addAttributesMutationObserver();\r\n        }\r\n        addAttributesMutationObserver() {\r\n            if (!this.model.attributesToWatch)\r\n                return;\r\n            let options = {\r\n                childList: false,\r\n                attributes: true,\r\n                characterData: false,\r\n                subtree: false,\r\n                attributeFilter: Object.keys(this.model.attributesToWatch),\r\n                attributeOldValue: false,\r\n                characterDataOldValue: false\r\n            };\r\n            const handleAttributesChange = (_) => {\r\n                let attributesLastChange = new Object();\r\n                for (let attribute in this.model.attributesToWatch) {\r\n                    const value = this.webComponentElement.getAttribute(attribute);\r\n                    attributesLastChange[attribute] = value;\r\n                }\r\n                if (this.model.attributesLastChange !== attributesLastChange)\r\n                    this.model.attributesLastChange = attributesLastChange;\r\n            };\r\n            let observer = new MutationObserver(handleAttributesChange);\r\n            observer.observe(this.webComponentElement, options);\r\n        }\r\n        addEventListeners() {\r\n            this.eventsCount = {};\r\n            for (let event in this.model.eventsToWatch) {\r\n                this.eventsCount[event] = 0;\r\n                this.webComponentElement.addEventListener(event, (ev) => this.eventHandler(ev), false);\r\n            }\r\n        }\r\n        transform_cds_to_records(cds) {\r\n            const data = [];\r\n            const columns = cds.columns();\r\n            const cdsLength = cds.get_length();\r\n            if (columns.length === 0 || cdsLength === null) {\r\n                return [];\r\n            }\r\n            for (let i = 0; i < cdsLength; i++) {\r\n                const item = {};\r\n                for (const column of columns) {\r\n                    let array = cds.get_array(column);\r\n                    const shape = array[0].shape == null ? null : array[0].shape;\r\n                    if ((shape != null) && (shape.length > 1) && (typeof shape[0] == \"number\"))\r\n                        item[column] = array.slice(i * shape[1], i * shape[1] + shape[1]);\r\n                    else\r\n                        item[column] = array[i];\r\n                }\r\n                data.push(item);\r\n            }\r\n            return data;\r\n        }\r\n        // https://stackoverflow.com/questions/5999998/check-if-a-variable-is-of-function-type\r\n        isFunction(functionToCheck) {\r\n            if (functionToCheck) {\r\n                const stringName = {}.toString.call(functionToCheck);\r\n                return stringName === '[object Function]' || stringName === '[object AsyncFunction]';\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Handles changes to `this.model.columnDataSource`\r\n         * by\r\n         * updating the data source of `this.webComponentElement`\r\n         * using the function or property specifed in `this.model.columnDataSourceLoadFunction`\r\n         */\r\n        handleColumnDataSourceChange() {\r\n            // @Philippfr: Right now we just reload all the data\r\n            // For example Perspective has an `update` function to append data\r\n            // Is this something we could/ should support?\r\n            if (this.model.columnDataSource) {\r\n                let data; // list\r\n                const columnDataSourceOrient = this.model.columnDataSourceOrient;\r\n                if (columnDataSourceOrient === \"records\")\r\n                    data = this.transform_cds_to_records(this.model.columnDataSource);\r\n                else\r\n                    data = this.model.columnDataSource.data; // @ts-ignore\r\n                const loadFunctionName = this.model.columnDataSourceLoadFunction.toString();\r\n                const loadFunction = this.webComponentElement[loadFunctionName];\r\n                if (this.isFunction(loadFunction))\r\n                    this.webComponentElement[loadFunctionName](data);\r\n                else\r\n                    this.webComponentElement[loadFunctionName] = data;\r\n            }\r\n            // Todo: handle situation where this.model.columnDataSource is null\r\n        }\r\n        activate_scripts(el) {\r\n            Array.from(el.querySelectorAll(\"script\")).forEach((oldScript) => {\r\n                const newScript = document.createElement(\"script\");\r\n                Array.from(oldScript.attributes)\r\n                    .forEach(attr => newScript.setAttribute(attr.name, attr.value));\r\n                newScript.appendChild(document.createTextNode(oldScript.innerHTML));\r\n                if (oldScript.parentNode)\r\n                    oldScript.parentNode.replaceChild(newScript, oldScript);\r\n            });\r\n        }\r\n        // See https://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key\r\n        /**\r\n         * Example:\r\n         *\r\n         * `get_nested_property(element, \"textInput.value\")` returns `element.textInput.value`\r\n         *\r\n         * @param element\r\n         * @param property_\r\n         */\r\n        get_nested_property(element, property_) {\r\n            property_ = property_.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\r\n            property_ = property_.replace(/^\\./, ''); // strip a leading dot\r\n            let a = property_.split('.');\r\n            for (let i = 0, n = a.length; i < n; ++i) {\r\n                let k = a[i];\r\n                if (k in element)\r\n                    element = element[k];\r\n                else\r\n                    return \"\";\r\n            }\r\n            return element;\r\n        }\r\n        set_nested_property(element, property_, value) {\r\n            // @Phillipfr: I need your help to understand and solve this\r\n            // hack: Setting the value of the WIRED-SLIDER before its ready\r\n            // will destroy the setter.\r\n            // I don't yet understand this.\r\n            // if ([\"WIRED-SLIDER\"].indexOf(element.tagName)>=0){\r\n            //   const setter = element.__lookupSetter__(property_);\r\n            //   if (!setter){return}\r\n            // }\r\n            const pList = property_.split('.');\r\n            if (pList.length === 1)\r\n                element[property_] = value;\r\n            else {\r\n                const len = pList.length;\r\n                for (let i = 0; i < len - 1; i++) {\r\n                    const elem = pList[i];\r\n                    if (!element[elem])\r\n                        element[elem] = {};\r\n                    element = element[elem];\r\n                }\r\n                element[pList[len - 1]] = value;\r\n            }\r\n        }\r\n        /**\r\n         * Handles events from `eventsToWatch` by\r\n         *\r\n         * - Incrementing the count of the event\r\n         * - Checking if any properties have changed\r\n         *\r\n         * @param ev The Event Fired\r\n         */\r\n        eventHandler(ev) {\r\n            let event = ev.type;\r\n            this.eventsCount[event] += 1;\r\n            let eventsCountLastChanged = {};\r\n            eventsCountLastChanged[event] = this.eventsCount[event];\r\n            this.model.eventsCountLastChange = eventsCountLastChanged;\r\n            this.checkIfPropertiesChanged();\r\n        }\r\n        /** Checks if any properties have changed. In case this is communicated to the server.\r\n         *\r\n         * For example the Wired `DropDown` does not run the `onchange` event handler when the selection changes.\r\n         * Insted the `select` event is fired. Thus we can subscribe to this event and manually check for property changes.\r\n         */\r\n        checkIfPropertiesChanged() {\r\n            const propertiesChange = {};\r\n            for (const property in this.model.propertiesToWatch) {\r\n                const oldValue = this.propertyValues[property];\r\n                const newValue = this.get_nested_property(this.webComponentElement, property);\r\n                if (oldValue != newValue) {\r\n                    propertiesChange[property] = newValue;\r\n                    this.propertyValues[property] = newValue;\r\n                }\r\n            }\r\n            if (Object.keys(propertiesChange).length)\r\n                this.model.propertiesLastChange = propertiesChange;\r\n        }\r\n        /** Handles the `WebComponentElement` `(on)change` event\r\n         *\r\n         * Communicates any changed properties in `propertiesToWatch` to the server\r\n         * by updating `this.model.propertiesLastChange`.\r\n         * @param ev\r\n         */\r\n        handlePropertiesChange(ev) {\r\n            const properties_change = new Object();\r\n            for (const property in this.model.propertiesToWatch) {\r\n                if (ev.detail && property in ev.detail) {\r\n                    properties_change[property] = ev.detail[property];\r\n                    this.propertyValues[property] = ev.detail[property];\r\n                }\r\n                else if (ev.target && property in ev.target) {\r\n                    properties_change[property] = ev.target[property];\r\n                    this.propertyValues[property] = ev.target[property];\r\n                }\r\n            }\r\n            if (Object.keys(properties_change).length)\r\n                this.model.propertiesLastChange = properties_change;\r\n        }\r\n        initPropertyValues() {\r\n            this.propertyValues = new Object();\r\n            if (!this.webComponentElement) {\r\n                return;\r\n            }\r\n            for (let property in this.model.propertiesToWatch) {\r\n                let old_value = this.propertyValues[property];\r\n                let new_value = this.get_nested_property(this.webComponentElement, property);\r\n                if (new_value !== old_value) {\r\n                    this.propertyValues[property] = new_value;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Handles changes to `this.model.attributesLastChange`\r\n         * by\r\n         * updating the attributes of `this.webComponentElement` accordingly\r\n         */\r\n        handleAttributesLastChangeChange() {\r\n            if (!this.webComponentElement)\r\n                return;\r\n            let attributesLastChange = this.model.attributesLastChange;\r\n            for (let attribute in this.model.attributesLastChange) {\r\n                if (attribute in this.model.attributesToWatch) {\r\n                    let old_value = this.webComponentElement.getAttribute(attribute);\r\n                    let new_value = attributesLastChange[attribute];\r\n                    if (old_value !== new_value) {\r\n                        if (new_value === null)\r\n                            this.webComponentElement.removeAttribute(attribute);\r\n                        else\r\n                            this.webComponentElement.setAttribute(attribute, new_value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n        * Handles changes to `this.model.propertiesLastChange`\r\n        * by\r\n        * updating the properties of `this.webComponentElement` accordingly\r\n        */\r\n        handlePropertiesLastChangeChange() {\r\n            if (!this.webComponentElement) {\r\n                return;\r\n            }\r\n            let propertiesLastChange = this.model.propertiesLastChange;\r\n            for (let property in this.model.propertiesLastChange) {\r\n                if (property in this.model.propertiesToWatch) {\r\n                    let value = propertiesLastChange[property];\r\n                    this.set_nested_property(this.webComponentElement, property, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.WebComponentView = WebComponentView;\r\n    WebComponentView.__name__ = \"WebComponentView\";\r\n    class WebComponent extends html_box_1.HTMLBox {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_WebComponent() {\r\n            this.prototype.default_view = WebComponentView;\r\n            this.define({\r\n                // @Philipfr: How do I make property types more specific\r\n                componentType: [p.String, 'htmlbox'],\r\n                innerHTML: [p.String, ''],\r\n                attributesToWatch: [p.Any],\r\n                attributesLastChange: [p.Any],\r\n                propertiesToWatch: [p.Any],\r\n                propertiesLastChange: [p.Any],\r\n                eventsToWatch: [p.Any],\r\n                eventsCountLastChange: [p.Any],\r\n                columnDataSource: [p.Any],\r\n                columnDataSourceOrient: [p.Any],\r\n                columnDataSourceLoadFunction: [p.Any],\r\n            });\r\n        }\r\n    }\r\n    exports.WebComponent = WebComponent;\r\n    WebComponent.__name__ = \"WebComponent\";\r\n    WebComponent.__module__ = \"awesome_panel_extensions.bokeh_extensions.web_component\";\r\n    WebComponent.init_WebComponent();\r\n}\r\n","/* bokeh_extensions\\tabulator_model.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(\"tslib\");\r\n    // See https://docs.bokeh.org/en/latest/docs/reference/models/layouts.html\r\n    const html_box_1 = require(\"@bokehjs/models/layouts/html_box\");\r\n    const dom_1 = require(\"@bokehjs/core/dom\");\r\n    // See https://docs.bokeh.org/en/latest/docs/reference/core/properties.html\r\n    const p = tslib_1.__importStar(require(\"@bokehjs/core/properties\"));\r\n    function set_size(el, model) {\r\n        let width_policy = model.width != null ? \"fixed\" : \"fit\";\r\n        let height_policy = model.height != null ? \"fixed\" : \"fit\";\r\n        const { sizing_mode } = model;\r\n        if (sizing_mode != null) {\r\n            if (sizing_mode == \"fixed\")\r\n                width_policy = height_policy = \"fixed\";\r\n            else if (sizing_mode == \"stretch_both\")\r\n                width_policy = height_policy = \"max\";\r\n            else if (sizing_mode == \"stretch_width\")\r\n                width_policy = \"max\";\r\n            else if (sizing_mode == \"stretch_height\")\r\n                height_policy = \"max\";\r\n            else {\r\n                switch (sizing_mode) {\r\n                    case \"scale_width\":\r\n                        width_policy = \"max\";\r\n                        height_policy = \"min\";\r\n                        break;\r\n                    case \"scale_height\":\r\n                        width_policy = \"min\";\r\n                        height_policy = \"max\";\r\n                        break;\r\n                    case \"scale_both\":\r\n                        width_policy = \"max\";\r\n                        height_policy = \"max\";\r\n                        break;\r\n                    default:\r\n                        throw new Error(\"unreachable\");\r\n                }\r\n            }\r\n        }\r\n        if (width_policy == \"fixed\" && model.width)\r\n            el.style.width = model.width + \"px\";\r\n        else if (width_policy == \"max\")\r\n            el.style.width = \"100%\";\r\n        if (height_policy == \"fixed\" && model.height)\r\n            el.style.height = model.height + \"px\";\r\n        else if (height_policy == \"max\")\r\n            el.style.height = \"100%\";\r\n    }\r\n    exports.set_size = set_size;\r\n    function transform_cds_to_records(cds) {\r\n        const data = [];\r\n        const columns = cds.columns();\r\n        const cdsLength = cds.get_length();\r\n        if (columns.length === 0 || cdsLength === null) {\r\n            return [];\r\n        }\r\n        for (let i = 0; i < cdsLength; i++) {\r\n            const item = {};\r\n            for (const column of columns) {\r\n                let array = cds.get_array(column);\r\n                const shape = array[0].shape == null ? null : array[0].shape;\r\n                if ((shape != null) && (shape.length > 1) && (typeof shape[0] == \"number\"))\r\n                    item[column] = array.slice(i * shape[1], i * shape[1] + shape[1]);\r\n                else\r\n                    item[column] = array[i];\r\n            }\r\n            data.push(item);\r\n        }\r\n        return data;\r\n    }\r\n    // The view of the Bokeh extension/ HTML element\r\n    // Here you can define how to render the model as well as react to model changes or View events.\r\n    class TabulatorModelView extends html_box_1.HTMLBoxView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._tabulator_cell_updating = false;\r\n        }\r\n        // objectElement: any // Element\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.configuration.change, () => {\r\n                this.render();\r\n            });\r\n            // this.connect(this.model.source.change, () => this.setData())\r\n            this.connect(this.model.source.properties.data.change, () => {\r\n                this.setData();\r\n            });\r\n            this.connect(this.model.source.streaming, () => this.addData());\r\n            this.connect(this.model.source.patching, () => this.updateOrAddData());\r\n            // this.connect(this.model.source.selected.change, () => this.updateSelection())\r\n            this.connect(this.model.source.selected.properties.indices.change, () => this.updateSelection());\r\n        }\r\n        render() {\r\n            super.render();\r\n            console.log(\"render\");\r\n            const container = dom_1.div({ class: \"pnx-tabulator\" });\r\n            set_size(container, this.model);\r\n            let configuration = this.getConfiguration();\r\n            // I'm working on getting this working in the notebook but have not yet found the solution\r\n            // See [Issue 1529](https://github.com/holoviz/panel/issues/15299)\r\n            if (typeof Tabulator === 'undefined') {\r\n                // Tabulator=require(\"tabulator-tables\")\r\n                // requirejs([\"https://unpkg.com/tabulator-tables\"]);\r\n                // Tabulator=requirejs(\"https://unpkg.com/tabulator-tables\");\r\n                console.log(\"Tabulator not loaded. See https://github.com/holoviz/panel/issues/15299\");\r\n            }\r\n            console.log(Tabulator);\r\n            this.tabulator = new Tabulator(container, configuration);\r\n            this.el.appendChild(container);\r\n        }\r\n        getConfiguration() {\r\n            // I refer to this via _view because this is the tabulator element when cellEdited is used\r\n            let _view = this;\r\n            function rowSelectionChanged(data, _) {\r\n                console.log(\"rowSelectionChanged\");\r\n                let indices = data.map((row) => row.index);\r\n                _view.model.source.selected.indices = indices;\r\n            }\r\n            function startUpdating() {\r\n                _view._tabulator_cell_updating = true;\r\n            }\r\n            function endUpdating() {\r\n                _view._tabulator_cell_updating = false;\r\n            }\r\n            function cellEdited(cell) {\r\n                console.log(\"cellEdited\");\r\n                const field = cell._cell.column.field;\r\n                const index = cell._cell.row.data.index;\r\n                const value = cell._cell.value;\r\n                startUpdating();\r\n                _view.model.source.patch({ [field]: [[index, value]] });\r\n                _view.model._cell_change = { \"c\": field, \"i\": index, \"v\": value };\r\n                endUpdating();\r\n            }\r\n            let default_configuration = {\r\n                \"rowSelectionChanged\": rowSelectionChanged,\r\n                \"cellEdited\": cellEdited,\r\n                \"index\": \"index\",\r\n            };\r\n            let configuration = Object.assign(Object.assign({}, this.model.configuration), default_configuration);\r\n            let data = this.model.source;\r\n            if (data === null || Object.keys(data.data).length === 0) {\r\n                return configuration;\r\n            }\r\n            else {\r\n                console.log(\"adding data to configuration\");\r\n                data = transform_cds_to_records(data);\r\n                return Object.assign(Object.assign({}, configuration), { \"data\": data });\r\n            }\r\n        }\r\n        after_layout() {\r\n            console.log(\"after_layout\");\r\n            super.after_layout();\r\n            this.tabulator.redraw(true);\r\n        }\r\n        setData() {\r\n            console.log(\"setData\");\r\n            let data = transform_cds_to_records(this.model.source);\r\n            this.tabulator.setData(data);\r\n        }\r\n        addData() {\r\n            console.log(\"addData\");\r\n            let data = transform_cds_to_records(this.model.source);\r\n            this.tabulator.setData(data);\r\n        }\r\n        updateOrAddData() {\r\n            // To avoid double updating the tabulator data\r\n            if (this._tabulator_cell_updating === true) {\r\n                return;\r\n            }\r\n            console.log(\"updateData\");\r\n            let data = transform_cds_to_records(this.model.source);\r\n            this.tabulator.setData(data);\r\n        }\r\n        updateSelection() {\r\n            console.log(\"updateSelection\");\r\n            if (this.tabulator == null) {\r\n                return;\r\n            }\r\n            let indices = this.model.source.selected.indices;\r\n            let selectedRows = this.tabulator.getSelectedRows();\r\n            for (let row of selectedRows) {\r\n                if (!indices.includes(row.getData().index)) {\r\n                    row.toggleSelect();\r\n                }\r\n            }\r\n            for (let index of indices) {\r\n                // Improve this\r\n                // Maybe tabulator should use id as index?\r\n                this.tabulator.selectRow(index);\r\n            }\r\n        }\r\n    }\r\n    exports.TabulatorModelView = TabulatorModelView;\r\n    TabulatorModelView.__name__ = \"TabulatorModelView\";\r\n    // The Bokeh .ts model corresponding to the Bokeh .py model\r\n    class TabulatorModel extends html_box_1.HTMLBox {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_TabulatorModel() {\r\n            this.prototype.default_view = TabulatorModelView;\r\n            this.define({\r\n                configuration: [p.Any,],\r\n                source: [p.Any,],\r\n                _cell_change: [p.Any,],\r\n            });\r\n        }\r\n    }\r\n    exports.TabulatorModel = TabulatorModel;\r\n    TabulatorModel.__name__ = \"TabulatorModel\";\r\n    TabulatorModel.__module__ = \"awesome_panel_extensions.bokeh_extensions.tabulator_model\";\r\n    TabulatorModel.init_TabulatorModel();\r\n}\r\n","/* bokeh_extensions\\perspective_viewer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(\"tslib\");\r\n    // Bokeh model for perspective-viewer\r\n    // See https://github.com/finos/perspective/tree/master/packages/perspective-viewer\r\n    // See https://docs.bokeh.org/en/latest/docs/reference/models/layouts.html\r\n    const html_box_1 = require(\"@bokehjs/models/layouts/html_box\");\r\n    const dom_1 = require(\"@bokehjs/core/dom\");\r\n    // See https://docs.bokeh.org/en/latest/docs/reference/core/properties.html\r\n    const p = tslib_1.__importStar(require(\"@bokehjs/core/properties\"));\r\n    const shared_1 = require(\"88538263fa\") /* ./shared */;\r\n    const PERSPECTIVE_VIEWER_CLASSES = [\r\n        \"perspective-viewer-material\",\r\n        \"perspective-viewer-material-dark\",\r\n        \"perspective-viewer-material-dense\",\r\n        \"perspective-viewer-material-dense-dark\",\r\n        \"perspective-viewer-vaporwave\",\r\n    ];\r\n    function is_not_perspective_class(item) {\r\n        return !PERSPECTIVE_VIEWER_CLASSES.includes(item);\r\n    }\r\n    function theme_to_class(theme) {\r\n        return \"perspective-viewer-\" + theme;\r\n    }\r\n    // The view of the Bokeh extension/ HTML element\r\n    // Here you can define how to render the model as well as react to model changes or View events.\r\n    class PerspectiveViewerView extends html_box_1.HTMLBoxView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.source.properties.data.change, this.setData);\r\n            this.connect(this.model.source_stream.properties.data.change, this.addData);\r\n            this.connect(this.model.source_patch.properties.data.change, this.updateOrAddData);\r\n            this.connect(this.model.properties.columns.change, this.updateColumns);\r\n            this.connect(this.model.properties.parsed_computed_columns.change, this.updateParsedComputedColumns);\r\n            this.connect(this.model.properties.computed_columns.change, this.updateComputedColumns);\r\n            this.connect(this.model.properties.column_pivots.change, this.updateColumnPivots);\r\n            this.connect(this.model.properties.row_pivots.change, this.updateRowPivots);\r\n            this.connect(this.model.properties.aggregates.change, this.updateAggregates);\r\n            this.connect(this.model.properties.filters.change, this.updateFilters);\r\n            this.connect(this.model.properties.plugin.change, this.updatePlugin);\r\n            this.connect(this.model.properties.theme.change, this.updateTheme);\r\n        }\r\n        render() {\r\n            super.render();\r\n            const container = dom_1.div({ class: \"pnx-perspective-viewer\" });\r\n            container.innerHTML = this.getInnerHTML();\r\n            this.perspective_element = container.children[0];\r\n            shared_1.set_size(container, this.model);\r\n            this.el.appendChild(container);\r\n            this.setData();\r\n            let viewer = this;\r\n            function handleConfigurationChange() {\r\n                // this refers to the perspective-viewer element\r\n                // viewer refers to the PerspectiveViewerView element\r\n                viewer.model.columns = this.columns; // Note columns is available as a property\r\n                viewer.model.column_pivots = JSON.parse(this.getAttribute(\"column-pivots\"));\r\n                viewer.model.parsed_computed_columns = JSON.parse(this.getAttribute(\"parsed-computed-columns\"));\r\n                viewer.model.computed_columns = JSON.parse(this.getAttribute(\"computed-columns\"));\r\n                viewer.model.row_pivots = JSON.parse(this.getAttribute(\"row-pivots\"));\r\n                viewer.model.aggregates = JSON.parse(this.getAttribute(\"aggregates\"));\r\n                viewer.model.sort = JSON.parse(this.getAttribute(\"sort\"));\r\n                viewer.model.filters = JSON.parse(this.getAttribute(\"filters\"));\r\n                // Perspective uses a plugin called 'debug' once in a while.\r\n                // We don't send this back to the python side\r\n                // Because then we would have to include it in the list of plugins\r\n                // the user can select from.\r\n                const plugin = this.getAttribute(\"plugin\");\r\n                if (plugin !== \"debug\") {\r\n                    viewer.model.plugin = this.getAttribute(\"plugin\");\r\n                }\r\n            }\r\n            this.perspective_element.addEventListener(\"perspective-config-update\", handleConfigurationChange);\r\n        }\r\n        getInnerHTML() {\r\n            let innerHTML = \"<perspective-viewer style='height:100%;width:100%;'\";\r\n            innerHTML += shared_1.toAttribute(\"class\", theme_to_class(this.model.theme));\r\n            innerHTML += shared_1.toAttribute(\"columns\", this.model.columns);\r\n            innerHTML += shared_1.toAttribute(\"column-pivots\", this.model.column_pivots);\r\n            innerHTML += shared_1.toAttribute(\"computed-columns\", this.model.computed_columns);\r\n            innerHTML += shared_1.toAttribute(\"row-pivots\", this.model.row_pivots);\r\n            innerHTML += shared_1.toAttribute(\"aggregates\", this.model.aggregates);\r\n            innerHTML += shared_1.toAttribute(\"sort\", this.model.sort);\r\n            innerHTML += shared_1.toAttribute(\"filters\", this.model.filters);\r\n            innerHTML += shared_1.toAttribute(\"plugin\", this.model.plugin);\r\n            innerHTML += \"></perspective-viewer>\";\r\n            // We don't set the parsed-computed-columns\r\n            // It's not documented. Don't know if it is an internal thing?\r\n            // I think it gets generated from the computed-columns currently\r\n            // innerHTML += toAttribute(\"parsed-computed-columns\", this.model.parsed_computed_columns)\r\n            return innerHTML;\r\n        }\r\n        setData() {\r\n            console.log(\"setData\");\r\n            console.log(this.model.source.data);\r\n            let data = shared_1.transform_cds_to_records(this.model.source);\r\n            this.perspective_element.load(data);\r\n        }\r\n        addData() {\r\n            // I need to find out how to only load the streamed data\r\n            // using this.perspective_element.update\r\n            console.log(\"addData\");\r\n            this.setData();\r\n        }\r\n        updateOrAddData() {\r\n            // I need to find out how to only load the patched data\r\n            // using this.perspective_element.update\r\n            console.log(\"updateOrAddData\");\r\n            this.setData();\r\n        }\r\n        updateAttribute(attribute, value, stringify) {\r\n            // Might need som more testing/ a better understanding\r\n            // I'm not sure we should return here.\r\n            if (value === undefined || value === null || value === []) {\r\n                return;\r\n            }\r\n            const old_value = this.perspective_element.getAttribute(attribute);\r\n            if (stringify) {\r\n                value = JSON.stringify(value);\r\n            }\r\n            // We should only set the attribute if the new value is different to old_value\r\n            // Otherwise we would get a recoursion/ stack overflow error\r\n            if (old_value !== value) {\r\n                this.perspective_element.setAttribute(attribute, value);\r\n            }\r\n        }\r\n        updateColumns() { this.updateAttribute(\"columns\", this.model.columns, true); }\r\n        updateParsedComputedColumns() { this.updateAttribute(\"parsed-computed-columns\", this.model.parsed_computed_columns, true); }\r\n        updateComputedColumns() { this.updateAttribute(\"computed-columns\", this.model.computed_columns, true); }\r\n        updateColumnPivots() { this.updateAttribute(\"column-pivots\", this.model.column_pivots, true); }\r\n        updateRowPivots() { this.updateAttribute(\"row-pivots\", this.model.row_pivots, true); }\r\n        updateAggregates() { this.updateAttribute(\"aggregates\", this.model.row_pivots, true); }\r\n        updateSort() { this.updateAttribute(\"sort\", this.model.sort, true); }\r\n        updateFilters() { this.updateAttribute(\"sort\", this.model.filters, true); }\r\n        updatePlugin() { this.updateAttribute(\"plugin\", this.model.plugin, false); }\r\n        updateTheme() {\r\n            // When you update the class attribute you have to be carefull\r\n            // For example when the user is dragging an element then 'dragging' is a part of the class attribute\r\n            let old_class = this.perspective_element.getAttribute(\"class\");\r\n            let new_class = this.toNewClassAttribute(old_class, this.model.theme);\r\n            this.perspective_element.setAttribute(\"class\", new_class);\r\n        }\r\n        /** Helper function to generate the new class attribute string\r\n         *\r\n         * If old_class = 'perspective-viewer-material dragging' and theme = 'material-dark'\r\n         * then 'perspective-viewer-material-dark dragging' is returned\r\n         *\r\n         * @param old_class For example 'perspective-viewer-material' or 'perspective-viewer-material dragging'\r\n         * @param theme The name of the new theme. For example 'material-dark'\r\n         */\r\n        toNewClassAttribute(old_class, theme) {\r\n            let new_classes = [];\r\n            if (old_class != null) {\r\n                new_classes = old_class.split(\" \").filter(is_not_perspective_class);\r\n            }\r\n            new_classes.push(theme_to_class(theme));\r\n            let new_class = new_classes.join(\" \");\r\n            return new_class;\r\n        }\r\n    }\r\n    exports.PerspectiveViewerView = PerspectiveViewerView;\r\n    PerspectiveViewerView.__name__ = \"PerspectiveViewerView\";\r\n    // The Bokeh .ts model corresponding to the Bokeh .py model\r\n    class PerspectiveViewer extends html_box_1.HTMLBox {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_PerspectiveViewer() {\r\n            this.prototype.default_view = PerspectiveViewerView;\r\n            this.define({\r\n                source: [p.Any,],\r\n                source_stream: [p.Any,],\r\n                source_patch: [p.Any,],\r\n                columns: [p.Array,],\r\n                parsed_computed_columns: [p.Array, []],\r\n                computed_columns: [p.Array,],\r\n                column_pivots: [p.Array,],\r\n                row_pivots: [p.Array,],\r\n                aggregates: [p.Any,],\r\n                sort: [p.Array,],\r\n                filters: [p.Array,],\r\n                plugin: [p.String,],\r\n                theme: [p.String,],\r\n            });\r\n        }\r\n    }\r\n    exports.PerspectiveViewer = PerspectiveViewer;\r\n    PerspectiveViewer.__name__ = \"PerspectiveViewer\";\r\n    PerspectiveViewer.__module__ = \"awesome_panel_extensions.bokeh_extensions.perspective_viewer\";\r\n    PerspectiveViewer.init_PerspectiveViewer();\r\n}\r\n","/* bokeh_extensions\\shared.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    /** Function copied from the panel\\models\\layout.ts file of Panel\r\n     * It is used for some models like deckgl, progress and vtlklayout\r\n     * I have not yet understood why\r\n     * @param el\r\n     * @param model\r\n     */\r\n    function set_size(el, model) {\r\n        let width_policy = model.width != null ? \"fixed\" : \"fit\";\r\n        let height_policy = model.height != null ? \"fixed\" : \"fit\";\r\n        const { sizing_mode } = model;\r\n        if (sizing_mode != null) {\r\n            if (sizing_mode == \"fixed\")\r\n                width_policy = height_policy = \"fixed\";\r\n            else if (sizing_mode == \"stretch_both\")\r\n                width_policy = height_policy = \"max\";\r\n            else if (sizing_mode == \"stretch_width\")\r\n                width_policy = \"max\";\r\n            else if (sizing_mode == \"stretch_height\")\r\n                height_policy = \"max\";\r\n            else {\r\n                switch (sizing_mode) {\r\n                    case \"scale_width\":\r\n                        width_policy = \"max\";\r\n                        height_policy = \"min\";\r\n                        break;\r\n                    case \"scale_height\":\r\n                        width_policy = \"min\";\r\n                        height_policy = \"max\";\r\n                        break;\r\n                    case \"scale_both\":\r\n                        width_policy = \"max\";\r\n                        height_policy = \"max\";\r\n                        break;\r\n                    default:\r\n                        throw new Error(\"unreachable\");\r\n                }\r\n            }\r\n        }\r\n        if (width_policy == \"fixed\" && model.width)\r\n            el.style.width = model.width + \"px\";\r\n        else if (width_policy == \"max\")\r\n            el.style.width = \"100%\";\r\n        if (height_policy == \"fixed\" && model.height)\r\n            el.style.height = model.height + \"px\";\r\n        else if (height_policy == \"max\")\r\n            el.style.height = \"100%\";\r\n    }\r\n    exports.set_size = set_size;\r\n    /** Transform the data of the cds to 'records' format, i.e. a list of objects\r\n     *\r\n     *  For example transforms to [{\"x\": 1, \"y\": 2}, {\"x\": 3, \"y\": 4}]\r\n     *\r\n     *  Some js libraries like perspective-viewer uses this format to load data.\r\n     *\r\n     * @param cds\r\n     */\r\n    function transform_cds_to_records(cds) {\r\n        const data = [];\r\n        const columns = cds.columns();\r\n        const cdsLength = cds.get_length();\r\n        if (columns.length === 0 || cdsLength === null) {\r\n            return [];\r\n        }\r\n        for (let i = 0; i < cdsLength; i++) {\r\n            const item = {};\r\n            for (const column of columns) {\r\n                let array = cds.get_array(column);\r\n                const shape = array[0].shape == null ? null : array[0].shape;\r\n                if ((shape != null) && (shape.length > 1) && (typeof shape[0] == \"number\"))\r\n                    item[column] = array.slice(i * shape[1], i * shape[1] + shape[1]);\r\n                else\r\n                    item[column] = array[i];\r\n            }\r\n            data.push(item);\r\n        }\r\n        return data;\r\n    }\r\n    exports.transform_cds_to_records = transform_cds_to_records;\r\n    /** Helper function used to incrementally build a html element string\r\n     *\r\n     *  For example toAttribute(\"columns\", ['x','y']) returns ' columns=\"['x','y']\"\r\n     *  For example toAttribute(\"columns\", null) returns \"\"\r\n     *\r\n     * @param attribute\r\n     * @param value\r\n     */\r\n    function toAttribute(attribute, value) {\r\n        if (value === null) {\r\n            return \"\";\r\n        }\r\n        if (typeof value !== \"string\") {\r\n            value = JSON.stringify(value);\r\n        }\r\n        return \" \" + attribute + \"='\" + value + \"'\";\r\n    }\r\n    exports.toAttribute = toAttribute;\r\n}\r\n"]}