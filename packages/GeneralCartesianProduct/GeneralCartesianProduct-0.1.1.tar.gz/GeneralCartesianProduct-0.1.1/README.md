Description
-------
`general_cartesian_product` extends the existing functionality of `itertools.product` by variable limits. It's possible 
to create cartesian products like:
```python
   i1           i2             i3
[1, 2, 3] x [1, ..., i1] x [0, ..., i2] = 
[
    [1, 1, 0]
    [1, 1, 1]
    [2, 1, 0]
    [2, 1, 1]
    [2, 2, 0]
    [2, 2, 1]
    [2, 2, 2]
    [3, 1, 0]
    [3, 1, 1]
    [3, 2, 0]
    [3, 2, 1]
    [3, 2, 2]
    [3, 3, 0]
    [3, 3, 1]
    [3, 3, 2]
    [3, 3, 3]
]
```
via this config file:
```python
rules = {
    'i1': { 'start': 1, 'end': 3, },
    'i2': { 'start': 1, 'end': i1, },
    'i3': { 'end': i2, },
}
```
Obviously this example is quite useless, because its the same as `[1,2,3]x[1,2,3]x[0,1,2,3]`
The whole thing becomes interesting if we have problems like this:
```python

[1, 2, 3] x [1, ..., 3-i1] x [0, ..., 3-i2] = 
[
    [1, 1, 0]
    [1, 1, 1]
    [1, 1, 2]
    [1, 2, 0]
    [1, 2, 1]
    [2, 1, 0]
    [2, 1, 1]
    [2, 1, 2]
]
```
which is generated by this configuration:
```python
rules = {
    'i1': {'start': 1, 'end': 3, },
    'i2': {'start': 1, 'end': 3-i1, },
    'i3': {'end': 3-i2, },
}
```

Limitations
------
Currently the only known limitation is that there must be always at least one constant limit. This means that the 
output of the cartesian product function will always be finite. To create 'infinite' generator like cartesian products 
a complete rewrite of this package is probably needed.

Installation
-------
This package depends on `sympy` (or `sage` symbolic variables e.g.:`i = var('i')`)
```shell script
pip install generalcartesianproduct sympy
```


Usage
-----
`sympy` Example:
```python
from sympy import symbols
from generalcartesianproduct.general_cartesian_product import *
i1, i2, u, v = symbols('i1,i2,u,v')

general_cartesian_product([i1, i2, i3])
```

`sage` Example:
```python
from generalcartesianproduct.general_cartesian_product import *
m = 4
i1, i2, u, v = var('i1,i2,u,v')
rules = {
    'i1': { 'end': m, },
    'i2': { 'end': m, },
    'u':  { 'end': min_symbolic(m-i1, m-i2), },
    'v':  { 'end': min_symbolic(m-i1, m-i2)-u, }
}
cp = general_cartesian_product([i1, i2, i3], rules)
print(cp)

```


How to use the `rules` dictionary.
------

```python
# simple example with only one dependency
rules = {
    'i1': { 'end': m, },
    'i2': { 'end': m-i1, },
}

```

TODO
----
- [ ] better logging
- [ ] add exceptions
- [ ] make `start`, `end` accesable via `kargs`