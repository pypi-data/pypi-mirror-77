Metadata-Version: 2.1
Name: GeneralCartesianProduct
Version: 0.1.1
Summary: extends the existing functionality of `itertools.product` by variable limits.
Home-page: https://github.com/FloydZ/generalcartesianproduct
Author: Floyd Z
Author-email: floyd.zweydinger+github@rub.de
License: LICENSE.txt
Description: Description
        -------
        `general_cartesian_product` extends the existing functionality of `itertools.product` by variable limits. It's possible 
        to create cartesian products like:
        ```python
           i1           i2             i3
        [1, 2, 3] x [1, ..., i1] x [0, ..., i2] = 
        [
            [1, 1, 0]
            [1, 1, 1]
            [2, 1, 0]
            [2, 1, 1]
            [2, 2, 0]
            [2, 2, 1]
            [2, 2, 2]
            [3, 1, 0]
            [3, 1, 1]
            [3, 2, 0]
            [3, 2, 1]
            [3, 2, 2]
            [3, 3, 0]
            [3, 3, 1]
            [3, 3, 2]
            [3, 3, 3]
        ]
        ```
        via this config file:
        ```python
        rules = {
            'i1': { 'start': 1, 'end': 3, },
            'i2': { 'start': 1, 'end': i1, },
            'i3': { 'end': i2, },
        }
        ```
        Obviously this example is quite useless, because its the same as `[1,2,3]x[1,2,3]x[0,1,2,3]`
        The whole thing becomes interesting if we have problems like this:
        ```python
        
        [1, 2, 3] x [1, ..., 3-i1] x [0, ..., 3-i2] = 
        [
            [1, 1, 0]
            [1, 1, 1]
            [1, 1, 2]
            [1, 2, 0]
            [1, 2, 1]
            [2, 1, 0]
            [2, 1, 1]
            [2, 1, 2]
        ]
        ```
        which is generated by this configuration:
        ```python
        rules = {
            'i1': {'start': 1, 'end': 3, },
            'i2': {'start': 1, 'end': 3-i1, },
            'i3': {'end': 3-i2, },
        }
        ```
        
        Limitations
        ------
        Currently the only known limitation is that there must be always at least one constant limit. This means that the 
        output of the cartesian product function will always be finite. To create 'infinite' generator like cartesian products 
        a complete rewrite of this package is probably needed.
        
        Installation
        -------
        This package depends on `sympy` (or `sage` symbolic variables e.g.:`i = var('i')`)
        ```shell script
        pip install generalcartesianproduct sympy
        ```
        
        
        Usage
        -----
        `sympy` Example:
        ```python
        from sympy import symbols
        from generalcartesianproduct.general_cartesian_product import *
        i1, i2, u, v = symbols('i1,i2,u,v')
        
        general_cartesian_product([i1, i2, i3])
        ```
        
        `sage` Example:
        ```python
        from generalcartesianproduct.general_cartesian_product import *
        m = 4
        i1, i2, u, v = var('i1,i2,u,v')
        rules = {
            'i1': { 'end': m, },
            'i2': { 'end': m, },
            'u':  { 'end': min_symbolic(m-i1, m-i2), },
            'v':  { 'end': min_symbolic(m-i1, m-i2)-u, }
        }
        cp = general_cartesian_product([i1, i2, i3], rules)
        print(cp)
        
        ```
        
        
        How to use the `rules` dictionary.
        ------
        
        ```python
        # simple example with only one dependency
        rules = {
            'i1': { 'end': m, },
            'i2': { 'end': m-i1, },
        }
        
        ```
        
        TODO
        ----
        - [ ] better logging
        - [ ] add exceptions
        - [ ] make `start`, `end` accesable via `kargs`
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)
Classifier: Operating System :: OS Independent
Requires-Python: >=3.6
Description-Content-Type: text/markdown
